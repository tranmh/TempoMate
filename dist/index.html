<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="description" content="TempoMate - Modern chess clock with advanced timing features">
  <meta name="theme-color" content="#c41e3a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>TempoMate - Chess Clock</title>
          <style>
/* --- css/themes.css --- */
/* ============================================
   TempoMate Theme System
   Dark/Light mode with Red accent
   ============================================ */

:root {
  /* Red accent */
  --accent: #c41e3a;
  --accent-hover: #a01830;
  --accent-light: #e85d73;

  /* Transition for theme changes */
  --theme-transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}

/* ===== Light Theme ===== */
:root,
[data-theme="light"] {
  --bg-primary: #f8f9fa;
  --bg-secondary: #ffffff;
  --bg-clock: #ffffff;
  --bg-clock-active: #e8f5e9;
  --bg-clock-paused: #fff8e1;
  --bg-clock-frozen: #fce4ec;
  --bg-toolbar: #ffffff;
  --bg-overlay: rgba(0, 0, 0, 0.5);
  --bg-settings: #ffffff;
  --bg-card: #f5f5f5;
  --bg-card-hover: #eeeeee;
  --bg-input: #ffffff;

  --text-primary: #1a1a1a;
  --text-secondary: #666666;
  --text-muted: #999999;
  --text-time: #1a1a1a;
  --text-time-active: #1a1a1a;
  --text-time-low: #e65100;
  --text-time-expired: #c41e3a;
  --text-on-accent: #ffffff;

  --border-color: #e0e0e0;
  --border-focus: #c41e3a;

  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);

  --flag-color: #c41e3a;
  --icon-color: #666666;
  --icon-active: #c41e3a;

  /* LCD Display — sage-green LCD, high contrast for outdoor/sunlight use */
  --lcd-bg: #c8d2b8;
  --lcd-text: #1c2b1c;
  --lcd-text-active: #0a1a0a;
  --lcd-ghost: #c8d2b8;
  --lcd-divider: rgba(28, 43, 28, 0.2);
  --lcd-bezel-outer: #787878;
  --lcd-bezel-inner: #606060;
  --lcd-accent-line: #c41e3a;
  --led-active: #4caf50;
  --led-paused: #f9a825;
  --led-frozen: #ef5350;
  --led-off: rgba(28, 43, 28, 0.15);
  --lcd-panel-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.15), inset 0 0 16px rgba(0, 0, 0, 0.06);
  --lcd-bezel-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.1);
  --lcd-bezel-highlight: inset 0 1px 0 rgba(255, 255, 255, 0.25);
}

/* ===== Dark Theme ===== */
[data-theme="dark"] {
  --bg-primary: #121212;
  --bg-secondary: #1e1e1e;
  --bg-clock: #1e1e1e;
  --bg-clock-active: #1b3a1e;
  --bg-clock-paused: #3a3520;
  --bg-clock-frozen: #3a1e1e;
  --bg-toolbar: #1e1e1e;
  --bg-overlay: rgba(0, 0, 0, 0.7);
  --bg-settings: #1e1e1e;
  --bg-card: #2a2a2a;
  --bg-card-hover: #333333;
  --bg-input: #2a2a2a;

  --text-primary: #e0e0e0;
  --text-secondary: #aaaaaa;
  --text-muted: #777777;
  --text-time: #e0e0e0;
  --text-time-active: #ffffff;
  --text-time-low: #ff9800;
  --text-time-expired: #ef5350;
  --text-on-accent: #ffffff;

  --border-color: #333333;
  --border-focus: #c41e3a;

  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
  --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);

  --flag-color: #ef5350;
  --icon-color: #aaaaaa;
  --icon-active: #ef5350;

  /* LCD Display — backlit LCD for indoor/night use */
  --lcd-bg: #0c0e0c;
  --lcd-text: #c8d8c0;
  --lcd-text-active: #e0f0d8;
  --lcd-ghost: #0c0e0c;
  --lcd-divider: rgba(200, 216, 192, 0.12);
  --lcd-bezel-outer: #2a2a2a;
  --lcd-bezel-inner: #1a1a1a;
  --lcd-accent-line: #c41e3a;
  --led-active: #4caf50;
  --led-paused: #f9a825;
  --led-frozen: #ef5350;
  --led-off: rgba(200, 216, 192, 0.1);
  --lcd-panel-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.6), inset 0 0 20px rgba(0, 0, 0, 0.3);
  --lcd-bezel-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), 0 1px 2px rgba(0, 0, 0, 0.3);
  --lcd-bezel-highlight: inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

/* --- css/styles.css --- */
/* ============================================
   TempoMate - Main Styles
   Modern minimal chess clock
   ============================================ */

/* ===== Reset & Base ===== */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  height: 100%;
  -webkit-text-size-adjust: 100%;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  height: 100%;
  overflow: hidden;
  transition: var(--theme-transition);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* ===== App Layout ===== */
#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  height: 100dvh; /* Dynamic viewport height for mobile */
  max-width: none;
  margin: 0 auto;
  padding: 8px;
  gap: 8px;
}

/* ===== Toolbar ===== */
.toolbar {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  background: var(--bg-toolbar);
  border-radius: 8px;
  box-shadow: var(--shadow-sm);
  flex-shrink: 0;
}

.toolbar-group {
  display: flex;
  align-items: center;
  gap: 4px;
}

.toolbar-brand {
  display: flex;
  align-items: center;
}

.logo {
  height: 28px;
  width: auto;
  color: var(--text-primary);
}

.toolbar-divider {
  width: 1px;
  height: 24px;
  background: var(--border-color);
  margin: 0 4px;
}

/* ===== Status Bar (inside LCD bezel) ===== */
.status-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 12px;
  font-size: 0.8rem;
  color: var(--lcd-text);
  opacity: 0.5;
  flex-shrink: 0;
  min-height: 24px;
  background: var(--lcd-bg);
  border-radius: 0 0 8px 8px;
  border-top: 1px solid var(--lcd-divider);
}

.status-left,
.status-right {
  display: flex;
  gap: 8px;
  align-items: center;
}

.status-center {
  display: flex;
  gap: 8px;
  align-items: center;
}

.status-method {
  font-weight: 500;
  text-transform: uppercase;
  font-size: 0.7rem;
  letter-spacing: 0.05em;
}

.status-period {
  font-size: 0.7rem;
  color: var(--lcd-accent-line);
  font-weight: 600;
}

.status-icon {
  font-size: 0.9rem;
}

.status-icon.hidden {
  display: none;
}

.freeze-icon {
  color: #64b5f6;
}

.sound-icon {
  color: var(--lcd-accent-line);
}

.status-option {
  font-weight: 600;
  font-variant-numeric: tabular-nums;
}

.status-state {
  font-size: 0.9rem;
}

.status-delay {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--lcd-accent-line);
  font-variant-numeric: tabular-nums;
}

.status-delay.hidden {
  display: none;
}

/* ===== Correction Mode Overlay ===== */
#correction-overlay {
  position: fixed;
  inset: 0;
  z-index: 200;
  background: var(--bg-overlay);
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
}

#correction-overlay.hidden {
  display: none;
}

.correction-container {
  background: var(--bg-settings);
  border-radius: 16px;
  box-shadow: var(--shadow-lg);
  padding: 24px;
  width: 100%;
  max-width: 440px;
}

.correction-title {
  font-size: 1.2rem;
  color: var(--text-primary);
  margin-bottom: 16px;
  text-align: center;
}

.correction-grid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 12px 16px;
  align-items: center;
  margin-bottom: 16px;
}

.correction-label {
  font-size: 0.85rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.correction-time,
.correction-moves-row,
.correction-period-row {
  display: flex;
  align-items: center;
  gap: 4px;
  font-family: 'SF Mono', 'Cascadia Mono', 'Fira Code', monospace;
  font-size: 1.4rem;
  color: var(--text-primary);
}

.correction-field {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 4px;
  min-width: 36px;
  text-align: center;
  transition: background 0.15s, color 0.15s;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

.correction-active {
  background: var(--accent);
  color: var(--text-on-accent);
  border-radius: 4px;
}

.correction-controls {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin-bottom: 16px;
}

.btn-control {
  width: 48px;
  height: 48px;
  font-size: 1.2rem;
  border-radius: 8px;
  border: 1px solid var(--border);
  background: var(--bg-settings);
  color: var(--text-primary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

.btn-control:active {
  background: var(--accent);
  color: var(--text-on-accent);
}

.btn-control-adj {
  width: 64px;
  font-size: 1.5rem;
  font-weight: bold;
}

.correction-buttons {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin-bottom: 12px;
}

.correction-help {
  font-size: 0.75rem;
  color: var(--text-muted);
  text-align: center;
}

/* ===== Footer ===== */
.app-footer {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  font-size: 0.7rem;
  color: var(--text-muted);
  flex-shrink: 0;
  padding: 4px 0;
}

.app-footer a {
  color: var(--text-muted);
  text-decoration: none;
}

.app-footer a:hover {
  color: var(--accent);
}

/* ===== Reset Confirm Animation ===== */
.confirm-active {
  animation: confirm-pulse 0.6s ease-in-out infinite;
  background: rgba(196, 30, 58, 0.15) !important;
  border-color: #c41e3a !important;
}

@keyframes confirm-pulse {
  0%, 100% { background: rgba(196, 30, 58, 0.15); }
  50% { background: rgba(196, 30, 58, 0.35); }
}

/* ===== Rotated Mode (90° for mobile flat-on-table) ===== */
#app.rotated {
  position: fixed;
  top: 0;
  left: 100vw;
  left: 100dvw;
  width: 100vh;
  width: 100dvh;
  height: 100vw;
  height: 100dvw;
  transform: rotate(90deg);
  transform-origin: top left;
}

#app.rotated .app-footer,
#app.rotated .toolbar-brand {
  display: none;
}

/* ===== Responsive: Small screens ===== */
@media (max-width: 400px) {
  #app {
    padding: 4px;
    gap: 4px;
  }

  .toolbar {
    padding: 2px 4px;
    gap: 4px;
    border-radius: 6px;
  }

  .btn-icon {
    width: 32px;
    height: 32px;
    font-size: 1rem;
  }

  .logo text {
    display: none;
  }

  .logo {
    width: 24px;
    overflow: hidden;
  }
}

/* ===== Prevent text selection on interactive elements ===== */
.clock-face,
.btn,
.btn-icon,
.preset-card,
.settings-tab {
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}

/* ===== Focus visible (keyboard only) ===== */
.clock-face:focus-visible,
.btn:focus-visible,
.btn-icon:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

/* ===== Scrollbar styling for settings ===== */
.settings-panel::-webkit-scrollbar {
  width: 6px;
}

.settings-panel::-webkit-scrollbar-track {
  background: transparent;
}

.settings-panel::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 3px;
}

.settings-panel::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* --- css/clock-display.css --- */
/* ============================================
   Clock Display Styles - LCD Theme
   ============================================ */

/* ===== Digital Clock Fonts ===== */
@font-face {
  font-family: 'DSEG7 Classic';
  src: url('data:font/woff2;base64,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') format('woff2');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'DSEG7 Modern';
  src: url('data:font/woff2;base64,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') format('woff2');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Orbitron';
  src: url('data:font/woff2;base64,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') format('woff2');
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Digital-7';
  src: url('data:font/woff2;base64,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') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

/* ===== LCD Bezel (physical casing) ===== */
.lcd-bezel {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-height: 0;
  background: linear-gradient(145deg, var(--lcd-bezel-outer), var(--lcd-bezel-inner));
  border-radius: 14px;
  padding: 6px;
  box-shadow:
    var(--lcd-bezel-shadow),
    var(--lcd-bezel-highlight);
  border: 3px solid var(--lcd-accent-line);
}

/* ===== Unified LCD Panel ===== */
.clock-container {
  display: flex;
  width: 100%;
  flex: 1;
  min-height: 0;
  background: var(--lcd-bg);
  border-radius: 8px 8px 0 0;
  box-shadow: var(--lcd-panel-shadow);
  position: relative;
  overflow: hidden;
}

/* Vertical divider between left/right clocks */
.clock-container::after {
  content: '';
  position: absolute;
  top: 12%;
  bottom: 12%;
  left: 50%;
  width: 1px;
  background: var(--lcd-divider);
  z-index: 1;
  pointer-events: none;
}

/* ===== Clock Face (transparent region within LCD) ===== */
.clock-face {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: none;
  border-radius: 0;
  padding: 16px;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
  transition: background 0.2s ease;
  position: relative;
  overflow: hidden;
  min-width: 0;
}

.clock-face:hover {
  background: rgba(255, 255, 255, 0.02);
}

.clock-face:active {
  transform: scale(0.98);
}

/* Active state: subtle LCD tint, no background color change */
.clock-face.active {
  background: transparent;
  border: none;
  box-shadow: none;
}

.clock-face.paused {
  background: transparent;
  border: none;
}

.clock-face.frozen {
  background: transparent;
  border: none;
  cursor: not-allowed;
}

/* ===== Clock Header (flag + LED + color) ===== */
.clock-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin-bottom: 8px;
  min-height: 24px;
}

/* ===== LED Indicator ===== */
.led-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--led-off);
  transition: background 0.2s ease, box-shadow 0.2s ease;
  flex-shrink: 0;
}

.active .led-indicator {
  background: var(--led-active);
  box-shadow: 0 0 6px var(--led-active), 0 0 12px rgba(76, 175, 80, 0.3);
}

.paused .led-indicator {
  background: var(--led-paused);
  box-shadow: 0 0 6px var(--led-paused), 0 0 12px rgba(249, 168, 37, 0.3);
}

.frozen .led-indicator {
  background: var(--led-frozen);
  box-shadow: 0 0 6px var(--led-frozen), 0 0 12px rgba(239, 83, 80, 0.3);
}

/* ===== Time Display Wrapper (for ghost segments) ===== */
.time-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ===== Ghost Segments (unlit LCD segments) ===== */
.clock-ghost {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--clock-font, 'DSEG7 Classic'), 'SF Mono', 'Cascadia Mono', 'Fira Code', 'Consolas', 'Courier New', monospace;
  font-size: 5rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: var(--lcd-ghost);
  line-height: 1;
  letter-spacing: 0.02em;
  white-space: nowrap;
  pointer-events: none;
  user-select: none;
}

/* ===== Time Display ===== */
.clock-time {
  font-family: var(--clock-font, 'DSEG7 Classic'), 'SF Mono', 'Cascadia Mono', 'Fira Code', 'Consolas', 'Courier New', monospace;
  font-size: 5rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: var(--lcd-text);
  line-height: 1;
  letter-spacing: 0.02em;
  white-space: nowrap;
  transition: color 0.2s ease;
  position: relative;
  z-index: 1;
}

.active .clock-time {
  color: var(--lcd-text-active);
}

.clock-time.time-low {
  color: var(--text-time-low);
}

.clock-time.time-expired {
  color: var(--text-time-expired);
}

/* ===== Clock Footer ===== */
.clock-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin-top: 8px;
  min-height: 20px;
  font-size: 0.85rem;
  color: var(--lcd-text);
  opacity: 0.6;
}

/* ===== Flag Indicator ===== */
.clock-flag {
  font-size: 1.5rem;
  color: var(--flag-color);
  transition: opacity 0.2s ease;
}

.flag-hidden {
  opacity: 0;
  visibility: hidden;
}

.flag-solid {
  opacity: 1;
  visibility: visible;
}

.flag-blinking {
  opacity: 1;
  visibility: visible;
  animation: flag-blink 0.5s ease-in-out infinite;
}

@keyframes flag-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.2; }
}

/* ===== Color Indicator (chess piece) ===== */
.clock-color {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid var(--lcd-text);
  opacity: 0.5;
}

.piece-white {
  background: transparent;
}

.piece-black {
  background: var(--lcd-text);
}

/* ===== Move Count ===== */
.clock-moves {
  font-size: 0.85rem;
  color: var(--lcd-text);
  opacity: 0.6;
  font-variant-numeric: tabular-nums;
}

/* ===== Byo-yomi Moments ===== */
.clock-byo {
  font-size: 0.85rem;
  color: var(--lcd-accent-line);
  font-weight: 600;
}

/* ===== Utility ===== */
.hidden {
  display: none !important;
}

/* ===== Responsive: Portrait (stacked) ===== */
@media (max-width: 600px) and (orientation: portrait) {
  .clock-container {
    flex-direction: column;
  }

  /* Vertical divider becomes horizontal in portrait */
  .clock-container::after {
    top: auto;
    bottom: auto;
    left: 12%;
    right: 12%;
    top: 50%;
    width: auto;
    height: 1px;
  }

  .clock-face {
    padding: 12px;
  }

  /* Rotate left clock 180 degrees so opposing player can read it */
  .clock-left {
    transform: rotate(180deg);
  }

  .clock-left.active {
    transform: rotate(180deg) scale(1);
  }

  .clock-left:active {
    transform: rotate(180deg) scale(0.98);
  }
}

/* ===== Rotated override in portrait: keep side-by-side layout ===== */
@media (max-width: 600px) and (orientation: portrait) {
  #app.rotated .clock-container {
    flex-direction: row;
  }

  /* Restore vertical divider */
  #app.rotated .clock-container::after {
    left: 50%;
    right: auto;
    top: 12%;
    bottom: 12%;
    width: 1px;
    height: auto;
  }

  /* Remove 180° rotation — whole UI is rotated instead */
  #app.rotated .clock-left {
    transform: none;
  }

  #app.rotated .clock-left.active {
    transform: none;
  }

  #app.rotated .clock-left:active {
    transform: scale(0.98);
  }
}

/* ===== Responsive: Landscape ===== */
@media (orientation: landscape) and (max-height: 500px) {
  .clock-face {
    padding: 8px;
  }

  .clock-header,
  .clock-footer {
    margin: 4px 0;
  }
}

/* --- css/settings-panel.css --- */
/* ============================================
   Settings Panel Styles
   ============================================ */

/* ===== Panel Container ===== */
#settings-panel {
  position: fixed;
  inset: 0;
  z-index: 100;
  background: var(--bg-overlay);
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 20px;
  overflow-y: auto;
}

#settings-panel.hidden {
  display: none;
}

.settings-panel {
  background: var(--bg-settings);
  border-radius: 16px;
  box-shadow: var(--shadow-lg);
  width: 100%;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
  padding: 24px;
  transition: var(--theme-transition);
}

/* ===== Header ===== */
.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.settings-header h2 {
  margin: 0;
  font-size: 1.3rem;
  color: var(--text-primary);
}

.settings-close {
  font-size: 1.2rem;
}

/* ===== Font Selector ===== */
.settings-font-group {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
  padding: 8px 12px;
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 8px;
}

.settings-font-group .form-label {
  margin: 0;
  font-size: 0.85rem;
  white-space: nowrap;
}

.settings-font-group .form-input {
  flex: 1;
  padding: 6px 10px;
  font-size: 0.85rem;
}

/* ===== Tabs ===== */
.settings-tabs {
  display: flex;
  gap: 4px;
  margin-bottom: 16px;
  border-bottom: 2px solid var(--border-color);
}

.settings-tab {
  background: none;
  border: none;
  padding: 8px 16px;
  font-size: 0.95rem;
  color: var(--text-secondary);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  margin-bottom: -2px;
  transition: color 0.2s, border-color 0.2s;
}

.settings-tab:hover {
  color: var(--text-primary);
}

.settings-tab.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
  font-weight: 600;
}

/* ===== Preset Grid ===== */
.settings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  gap: 8px;
}

.preset-card {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 12px;
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  text-align: left;
  transition: background 0.15s, border-color 0.15s, box-shadow 0.15s;
}

.preset-card:hover {
  background: var(--bg-card-hover);
  border-color: var(--accent);
  box-shadow: var(--shadow-sm);
}

.preset-number {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-weight: 600;
}

.preset-name {
  font-size: 0.95rem;
  font-weight: 600;
  color: var(--text-primary);
}

.preset-desc {
  font-size: 0.8rem;
  color: var(--text-secondary);
  line-height: 1.3;
}

.preset-method {
  font-size: 0.7rem;
  color: var(--accent);
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* ===== Custom List ===== */
.custom-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.custom-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 8px;
}

.custom-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.custom-label {
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--text-primary);
}

.custom-desc {
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.custom-actions {
  display: flex;
  gap: 8px;
}

/* ===== Custom Edit Form ===== */
.custom-edit-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.form-label {
  font-size: 0.85rem;
  color: var(--text-secondary);
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
}

.form-input {
  background: var(--bg-input);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 0.95rem;
  color: var(--text-primary);
  transition: border-color 0.2s;
}

.form-input:focus {
  outline: none;
  border-color: var(--border-focus);
  box-shadow: 0 0 0 2px rgba(196, 30, 58, 0.15);
}

.form-input-highlight {
  border-color: var(--accent) !important;
  box-shadow: 0 0 0 3px rgba(196, 30, 58, 0.25) !important;
  animation: pulse-border 0.6s ease-in-out 2;
}

@keyframes pulse-border {
  0%, 100% { box-shadow: 0 0 0 3px rgba(196, 30, 58, 0.25); }
  50% { box-shadow: 0 0 0 5px rgba(196, 30, 58, 0.15); }
}

.name-hint {
  display: block;
  font-size: 0.8rem;
  color: var(--accent);
  margin-top: 4px;
  font-weight: 500;
}

.form-input-time {
  width: 60px;
  text-align: center;
  padding: 8px 4px;
}

.time-input-group {
  display: flex;
  align-items: center;
  gap: 4px;
  flex-wrap: wrap;
}

.time-input-label {
  font-size: 0.8rem;
  color: var(--text-secondary);
  margin-right: 8px;
  min-width: 120px;
}

.time-input-suffix {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-weight: 500;
  margin-right: 6px;
}

.form-buttons {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  margin-top: 8px;
}

/* ===== Period Form ===== */
.periods-section h3 {
  font-size: 1rem;
  color: var(--text-primary);
  margin: 0 0 8px 0;
}

.period-form {
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 8px;
}

.period-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-weight: 600;
  font-size: 0.9rem;
  color: var(--text-primary);
}

.defaults-section {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
}

/* ===== Buttons ===== */
.btn {
  border: none;
  border-radius: 6px;
  padding: 8px 16px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.15s, color 0.15s, opacity 0.15s;
  white-space: nowrap;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-primary {
  background: var(--accent);
  color: var(--text-on-accent);
}

.btn-primary:hover:not(:disabled) {
  background: var(--accent-hover);
}

.btn-secondary {
  background: var(--bg-card);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}

.btn-secondary:hover:not(:disabled) {
  background: var(--bg-card-hover);
}

.btn-icon {
  background: none;
  border: none;
  color: var(--icon-color);
  padding: 6px;
  font-size: 1.1rem;
  cursor: pointer;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.15s, color 0.15s;
}

.btn-icon:hover {
  background: var(--bg-card);
  color: var(--text-primary);
}

.btn-icon.active {
  color: var(--icon-active);
}

.btn-sm {
  padding: 4px 12px;
  font-size: 0.8rem;
}

/* ===== Responsive ===== */
@media (max-width: 500px) {
  #settings-panel {
    padding: 8px;
  }

  .settings-panel {
    padding: 16px;
    border-radius: 12px;
  }

  .settings-grid {
    grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    gap: 6px;
  }

  .preset-card {
    padding: 10px;
  }
}
  </style>
</head>
<body>
  <div id="app">
    <!-- Toolbar -->
    <div class="toolbar">
      <div class="toolbar-group toolbar-brand">
        <svg class="logo" viewBox="0 0 140 28" aria-label="TempoMate logo">
          <!-- Clock icon: two clock faces with toggle lever -->
          <rect x="1" y="6" width="10" height="16" rx="2" fill="none" stroke="currentColor" stroke-width="1.5"/>
          <rect x="13" y="6" width="10" height="16" rx="2" fill="none" stroke="currentColor" stroke-width="1.5"/>
          <line x1="6" y1="10" x2="6" y2="14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="18" y1="10" x2="18" y2="14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          <!-- Toggle lever -->
          <path d="M8 6 L12 2 L16 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          <!-- Text -->
          <text x="28" y="20" font-family="-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif" font-size="16" font-weight="700">
            <tspan fill="#c41e3a">Tempo</tspan><tspan fill="currentColor">Mate</tspan>
          </text>
        </svg>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-group">
        <button id="btn-settings" class="btn-icon" title="Settings" aria-label="Open settings">
          &#9881;<!-- Gear -->
        </button>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-group">
        <button id="btn-pause" class="btn-icon" title="Pause (P)" aria-label="Pause/Resume" disabled>
          &#9208;<!-- Pause -->
        </button>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-group">
        <button id="btn-reset" class="btn-icon" title="Reset (R)" aria-label="Reset clock">
          &#8634;<!-- Reset arrow -->
        </button>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-group">
        <button id="btn-sound" class="btn-icon" title="Sound (S)" aria-label="Toggle sound">
          &#9834;<!-- Musical note -->
        </button>
        <button id="btn-theme" class="btn-icon" title="Theme" aria-label="Toggle theme">
          &#9680;<!-- Half circle -->
        </button>
      </div>

      <div class="toolbar-divider"></div>

      <div class="toolbar-group">
        <button id="btn-rotate" class="btn-icon" title="Rotate 90°" aria-label="Toggle 90° rotation">
          &#8635;<!-- Clockwise arrow -->
        </button>
      </div>
    </div>

    <!-- LCD Bezel (wraps clock + status bar like a physical chess clock) -->
    <div class="lcd-bezel">
      <!-- Clock Display -->
      <div id="clock-container" role="main" aria-label="Chess clock display"></div>

      <!-- Status Bar (inside the LCD panel) -->
      <div id="status-bar" role="status" aria-live="polite"></div>
    </div>

    <noscript><p>TempoMate requires JavaScript to run.</p></noscript>

    <footer class="app-footer">
      <a href="https://cuong.net/tempomate" target="_blank">cuong.net/tempomate</a>
      <span>|</span>
      <a href="https://github.com/tranmh/TempoMate" target="_blank">GitHub</a>
    </footer>
  </div>

  <!-- Settings Panel Overlay -->
  <div id="settings-panel" class="hidden"></div>

  <!-- Correction Mode Overlay -->
  <div id="correction-overlay" class="hidden"></div>

    <script>
// --- js/utils/constants.js ---
/**
 * Application-wide constants for TempoMate
 */

/** Game states */
const GameStatus = Object.freeze({
  IDLE: 'idle',
  RUNNING: 'running',
  PAUSED: 'paused',
  FROZEN: 'frozen',
  CORRECTING: 'correcting',
});

/** Player identifiers */
const Player = Object.freeze({
  LEFT: 'left',
  RIGHT: 'right',
});

/** Timing method identifiers */
const TimingMethodType = Object.freeze({
  TIME: 'TIME',
  FISCHER: 'FISCH',
  US_DELAY: 'US-DLY',
  DELAY: 'DELAY',
  BYO_YOMI: 'BYO',
  CANADIAN_BYO: 'CAN-BYO',
  UPCOUNT: 'UPCNT',
  END: 'END',
});

/** Flag states */
const FlagState = Object.freeze({
  NONE: 'none',
  BLINKING: 'blinking',       // Final period expired
  NON_BLINKING: 'non_blinking', // Non-final period expired
});

/** Maximum configurable values */
const Limits = Object.freeze({
  MAX_PERIODS: 4,
  MAX_BYO_MOMENTS: 99,
  MAX_CANADIAN_TIME_MS: 599000, // 9:59
  MAX_HOURS: 9,
  MAX_MANUAL_OPTIONS: 5,
  MANUAL_OPTION_START: 27,
  MANUAL_OPTION_END: 31,
  TOTAL_PRESETS: 26,           // Options 1-26
  FLAG_DISPLAY_DURATION_MS: 300000, // 5 minutes
});

/** Clock font identifiers */
const ClockFont = Object.freeze({
  DSEG7_CLASSIC: 'dseg7-classic',
  DSEG7_MODERN: 'dseg7-modern',
  ORBITRON: 'orbitron',
  DIGITAL7: 'digital7',
  MONOSPACE: 'monospace',
});

/** Clock font display definitions */
const CLOCK_FONTS = Object.freeze([
  { id: ClockFont.DSEG7_CLASSIC, name: 'DSEG7 Classic', family: "'DSEG7 Classic'" },
  { id: ClockFont.DSEG7_MODERN, name: 'DSEG7 Modern', family: "'DSEG7 Modern'" },
  { id: ClockFont.ORBITRON, name: 'Orbitron', family: "'Orbitron'" },
  { id: ClockFont.DIGITAL7, name: 'Digital-7', family: "'Digital-7'" },
  { id: ClockFont.MONOSPACE, name: 'Monospace', family: "'SF Mono', 'Cascadia Mono', 'Fira Code', 'Consolas', 'Courier New', monospace" },
]);

/** Sound configuration */
const SoundConfig = Object.freeze({
  WARNING_TIME_MS: 10000,     // Beep at 10 seconds
  COUNTDOWN_START_MS: 5000,   // Beep every second in last 5 seconds
  FINAL_BEEP_MS: 1000,        // Longer beep in last second
  BEEP_FREQUENCY: 880,        // Hz - A5
  BEEP_DURATION_SHORT: 80,    // ms
  BEEP_DURATION_LONG: 300,    // ms
  BEEP_VOLUME: 0.5,
});

/** Keyboard shortcuts */
const Keys = Object.freeze({
  SWITCH_TURN: [' ', 'Enter'],
  PAUSE: ['p', 'P'],
  SOUND_TOGGLE: ['s', 'S'],
  FREEZE_TOGGLE: ['f', 'F'],
  MOVE_COUNT: ['m', 'M'],
  RESET: ['r', 'R'],
  ESCAPE: ['Escape'],
  NAV_LEFT: ['ArrowLeft'],
  NAV_RIGHT: ['ArrowRight'],
  NAV_UP: ['ArrowUp'],
  NAV_DOWN: ['ArrowDown'],
});

/** UI timing */
const UIConfig = Object.freeze({
  LONG_PRESS_MS: 3000,        // 3 second hold
  DISPLAY_UPDATE_INTERVAL: 50, // ms between display refreshes
  FLAG_BLINK_INTERVAL: 500,   // ms
  DEBOUNCE_MS: 100,
});

/** localStorage keys */
const StorageKeys = Object.freeze({
  CUSTOM_OPTIONS: 'tempomate_custom_options',
  LAST_OPTION: 'tempomate_last_option',
  THEME: 'tempomate_theme',
  SOUND_ENABLED: 'tempomate_sound',
  FONT: 'tempomate_font',
  ROTATION: 'tempomate_rotation',
});

// --- js/state/PlayerState.js ---
/**
 * PlayerState - Per-player state for the clock
 *
 * Tracks remaining time, current period, move count, flag status,
 * and timing method state for a single player.
 */


class PlayerState {
  /**
   * @param {string} side - Player.LEFT or Player.RIGHT
   */
  constructor(side) {
    /** @type {string} */
    this.side = side;

    /** @type {number} Remaining time in milliseconds */
    this.timeMs = 0;

    /** @type {number} Current period index (0-based) */
    this.currentPeriod = 0;

    /** @type {number} Move count */
    this.moves = 0;

    /** @type {string} Flag state */
    this.flagState = FlagState.NONE;

    /** @type {number|null} Timestamp when flag was set (for auto-hide after 5 min) */
    this.flagSetTime = null;

    /** @type {string} Color assignment: 'white' or 'black' */
    this.color = side === Player.LEFT ? 'white' : 'black';

    /** @type {number} Delay countdown remaining (for US-Delay display) */
    this.delayRemainingMs = 0;

    /** @type {boolean} Whether delay is currently counting (for US-Delay) */
    this.inDelay = false;

    /** @type {number} Time at the start of the current turn (for Bronstein) */
    this.turnStartTimeMs = 0;

    /** @type {number} Current byo-yomi moments remaining */
    this.byoMomentsRemaining = 0;

    /** @type {number} Time at start of current byo-yomi moment */
    this.byoMomentTimeMs = 0;

    /** @type {boolean} Whether player has started their first move */
    this.hasStarted = false;
  }

  /**
   * Initialize the player state with a time control configuration.
   * @param {object} periodConfig - Configuration for the initial period
   * @param {number} periodConfig.timeMs - Main time in milliseconds
   * @param {number} [periodConfig.delayMs] - Delay/bonus time per move
   * @param {number} [periodConfig.byoMoments] - Number of byo-yomi moments
   * @param {number} [periodConfig.byoTimeMs] - Time per byo-yomi moment
   */
  init(periodConfig) {
    this.timeMs = periodConfig.timeMs ?? 0;
    this.currentPeriod = 0;
    this.moves = 0;
    this.flagState = FlagState.NONE;
    this.flagSetTime = null;
    this.delayRemainingMs = 0;
    this.inDelay = false;
    this.turnStartTimeMs = 0;
    this.byoMomentsRemaining = periodConfig.byoMoments ?? 0;
    this.byoMomentTimeMs = periodConfig.byoTimeMs ?? 0;
    this.hasStarted = false;
  }

  /**
   * Reset flag state.
   */
  clearFlag() {
    this.flagState = FlagState.NONE;
    this.flagSetTime = null;
  }

  /**
   * Set a flag on this player.
   * @param {string} state - FlagState.BLINKING or FlagState.NON_BLINKING
   */
  setFlag(state) {
    this.flagState = state;
    this.flagSetTime = Date.now();
  }

  /**
   * Swap color assignment (used in correction mode).
   */
  swapColor() {
    this.color = this.color === 'white' ? 'black' : 'white';
  }

  /**
   * Create a snapshot of the current state (for undo/correction).
   * @returns {object}
   */
  snapshot() {
    return {
      timeMs: this.timeMs,
      currentPeriod: this.currentPeriod,
      moves: this.moves,
      flagState: this.flagState,
      flagSetTime: this.flagSetTime,
      color: this.color,
      delayRemainingMs: this.delayRemainingMs,
      inDelay: this.inDelay,
      turnStartTimeMs: this.turnStartTimeMs,
      byoMomentsRemaining: this.byoMomentsRemaining,
      byoMomentTimeMs: this.byoMomentTimeMs,
      hasStarted: this.hasStarted,
    };
  }

  /**
   * Restore from a snapshot.
   * @param {object} snap
   */
  restore(snap) {
    // Only restore known fields to prevent prototype pollution or stale data
    this.timeMs = snap.timeMs;
    this.currentPeriod = snap.currentPeriod;
    this.moves = snap.moves;
    this.flagState = snap.flagState;
    this.flagSetTime = snap.flagSetTime ?? null;
    this.color = snap.color;
    this.delayRemainingMs = snap.delayRemainingMs;
    this.inDelay = snap.inDelay;
    this.turnStartTimeMs = snap.turnStartTimeMs ?? 0;
    this.byoMomentsRemaining = snap.byoMomentsRemaining;
    this.byoMomentTimeMs = snap.byoMomentTimeMs;
    this.hasStarted = snap.hasStarted;
  }
}

// --- js/state/GameState.js ---
/**
 * GameState - Central game state management
 *
 * Manages the overall clock state, active player, timing configuration,
 * and coordinates between the timer engine and player states.
 */


class GameState {
  constructor() {
    /** @type {string} Current game status */
    this.status = GameStatus.IDLE;

    /** @type {string|null} Currently active player (whose clock is running) */
    this.activePlayer = null;

    /** @type {PlayerState} */
    this.left = new PlayerState(Player.LEFT);

    /** @type {PlayerState} */
    this.right = new PlayerState(Player.RIGHT);

    /** @type {number} Selected option number (1-30) */
    this.selectedOption = 1;

    /** @type {object|null} Full option configuration */
    this.optionConfig = null;

    /** @type {boolean} Whether freeze mode is active */
    this.freezeEnabled = false;

    /** @type {boolean} Whether sound is enabled */
    this.soundEnabled = false;

    /** @type {boolean} Whether the game has been started at least once */
    this.hasBeenStarted = false;

    /** @type {string|null} Status before entering correction mode */
    this._preCorrectionStatus = null;

    /** @type {Array<Function>} State change listeners */
    this._listeners = [];
  }

  /**
   * Subscribe to state changes.
   * @param {Function} listener - (gameState: GameState) => void
   * @returns {Function} Unsubscribe function
   */
  onChange(listener) {
    this._listeners.push(listener);
    return () => {
      this._listeners = this._listeners.filter((l) => l !== listener);
    };
  }

  /**
   * Notify all listeners of a state change.
   */
  notify() {
    for (const listener of this._listeners) {
      try {
        listener(this);
      } catch (e) {
        console.error('State listener error:', e);
      }
    }
  }

  /**
   * Get the PlayerState for a given side.
   * @param {string} side - Player.LEFT or Player.RIGHT
   * @returns {PlayerState}
   */
  getPlayer(side) {
    if (side === Player.LEFT) return this.left;
    if (side === Player.RIGHT) return this.right;
    throw new Error(`Invalid player side: ${side}`);
  }

  /**
   * Get the opponent's PlayerState.
   * @param {string} side - Player.LEFT or Player.RIGHT
   * @returns {PlayerState}
   */
  getOpponent(side) {
    return side === Player.LEFT ? this.right : this.left;
  }

  /**
   * Get the active PlayerState.
   * @returns {PlayerState|null}
   */
  getActivePlayerState() {
    if (!this.activePlayer) return null;
    return this.getPlayer(this.activePlayer);
  }

  /**
   * Initialize the game with an option configuration.
   * @param {object} config - Option configuration
   * @param {Array} config.periods - Array of period configurations
   * @param {boolean} [config.freezeDefault] - Default freeze setting
   * @param {boolean} [config.soundDefault] - Default sound setting
   * @param {number} [config.leftTimeMs] - Override left player time (for asymmetric)
   * @param {number} [config.rightTimeMs] - Override right player time (for asymmetric)
   */
  initGame(config) {
    this.optionConfig = config;
    this.status = GameStatus.IDLE;
    this.activePlayer = null;
    this.hasBeenStarted = false;

    // Set defaults based on config
    this.freezeEnabled = config.freezeDefault ?? false;
    this.soundEnabled = config.soundDefault ?? false;

    // Validate periods
    if (!config.periods || config.periods.length === 0) {
      throw new Error('Config must have at least one period');
    }

    // Initialize both players with first period
    const firstPeriod = config.periods[0];

    this.left.init({
      timeMs: config.leftTimeMs ?? firstPeriod.timeMs,
      delayMs: firstPeriod.delayMs,
      byoMoments: firstPeriod.byoMoments,
      byoTimeMs: firstPeriod.byoTimeMs,
    });

    this.right.init({
      timeMs: config.rightTimeMs ?? firstPeriod.timeMs,
      delayMs: firstPeriod.delayMs,
      byoMoments: firstPeriod.byoMoments,
      byoTimeMs: firstPeriod.byoTimeMs,
    });

    // Reset color assignments
    this.left.color = 'white';
    this.right.color = 'black';

    this.notify();
  }

  /**
   * Start the clock. The active player is determined by which side taps.
   * @param {string} side - The side that tapped (their opponent's clock starts)
   */
  startGame(side) {
    // The side that taps ends their turn => opponent's clock starts
    this.activePlayer = side === Player.LEFT ? Player.RIGHT : Player.LEFT;
    this.status = GameStatus.RUNNING;
    this.hasBeenStarted = true;

    // The player who taps first is white (white moves first in chess)
    this.getPlayer(side).color = 'white';
    this.getOpponent(side).color = 'black';

    this.notify();
  }

  /**
   * Switch turns (current active player tapped their clock).
   */
  switchTurn() {
    if (this.status !== GameStatus.RUNNING) return;

    const currentPlayer = this.getActivePlayerState();
    if (currentPlayer) {
      currentPlayer.moves++;
    }

    this.activePlayer = this.activePlayer === Player.LEFT ? Player.RIGHT : Player.LEFT;
    this.notify();
  }

  /**
   * Pause the clock.
   */
  pause() {
    if (this.status === GameStatus.RUNNING) {
      this.status = GameStatus.PAUSED;
      this.notify();
    }
  }

  /**
   * Resume the clock from pause.
   */
  resume() {
    if (this.status === GameStatus.PAUSED) {
      this.status = GameStatus.RUNNING;
      this.notify();
    }
  }

  /**
   * Toggle pause/resume.
   */
  togglePause() {
    if (this.status === GameStatus.RUNNING) {
      this.pause();
    } else if (this.status === GameStatus.PAUSED) {
      this.resume();
    }
  }

  /**
   * Freeze the clock (player lost on time).
   */
  freeze() {
    if (this.status === GameStatus.RUNNING || this.status === GameStatus.PAUSED) {
      this.status = GameStatus.FROZEN;
      this.notify();
    }
  }

  /**
   * Enter correction mode.
   */
  enterCorrectionMode() {
    if (this.status === GameStatus.PAUSED || this.status === GameStatus.FROZEN) {
      this._preCorrectionStatus = this.status;
      this.status = GameStatus.CORRECTING;
      this.notify();
    }
  }

  /**
   * Exit correction mode. Restores the status from before entering correction.
   */
  exitCorrectionMode() {
    if (this.status === GameStatus.CORRECTING) {
      this.status = this._preCorrectionStatus || GameStatus.PAUSED;
      this._preCorrectionStatus = null;
      this.notify();
    }
  }

  /**
   * Reset the game with the same configuration.
   */
  reset() {
    if (this.optionConfig) {
      this.initGame(this.optionConfig);
    }
  }

  /**
   * Toggle sound.
   */
  toggleSound() {
    this.soundEnabled = !this.soundEnabled;
    this.notify();
  }

  /**
   * Toggle freeze mode (only before first start).
   * @returns {boolean} Whether the toggle was applied
   */
  toggleFreeze() {
    if (!this.hasBeenStarted) {
      this.freezeEnabled = !this.freezeEnabled;
      this.notify();
      return true;
    }
    return false;
  }

  /**
   * Get the current period config for a player.
   * @param {string} side
   * @returns {object|null} Period configuration
   */
  getCurrentPeriodConfig(side) {
    if (!this.optionConfig) return null;
    const player = this.getPlayer(side);
    return this.optionConfig.periods[player.currentPeriod] || null;
  }

  /**
   * Check if a player is in their final period.
   * @param {string} side
   * @returns {boolean}
   */
  isInFinalPeriod(side) {
    if (!this.optionConfig) return true;
    const player = this.getPlayer(side);
    return player.currentPeriod >= this.optionConfig.periods.length - 1;
  }

  /**
   * Check if the game is in a playable state.
   * @returns {boolean}
   */
  isPlayable() {
    return this.status === GameStatus.RUNNING || this.status === GameStatus.IDLE;
  }
}

// --- js/engine/TimerEngine.js ---
/**
 * TimerEngine - High-precision timer using requestAnimationFrame + performance.now()
 *
 * Provides accurate time tracking with minimal drift, handles background tab detection,
 * and calls a tick callback with elapsed delta each frame.
 */

class TimerEngine {
  constructor() {
    /** @type {number|null} */
    this._rafId = null;
    /** @type {number} Last timestamp from performance.now() */
    this._lastTimestamp = 0;
    /** @type {boolean} */
    this._running = false;
    /** @type {Function|null} Callback: (deltaMs: number) => void */
    this._onTick = null;
    /** @type {Function|null} */
    this._onVisibilityChange = null;
    /** @type {number} Wall-clock timestamp (Date.now()) when tab became hidden */
    this._hiddenAtWallClock = 0;

    this._boundTick = this._tick.bind(this);
    this._boundVisibilityChange = this._handleVisibilityChange.bind(this);
  }

  /**
   * Set the tick callback.
   * @param {(deltaMs: number) => void} callback
   */
  setTickCallback(callback) {
    this._onTick = callback;
  }

  /**
   * Start the timer loop.
   */
  start() {
    if (this._running) return;
    this._running = true;
    this._lastTimestamp = performance.now();
    this._rafId = requestAnimationFrame(this._boundTick);

    document.addEventListener('visibilitychange', this._boundVisibilityChange);
  }

  /**
   * Stop the timer loop.
   */
  stop() {
    if (!this._running) return;
    this._running = false;
    if (this._rafId !== null) {
      cancelAnimationFrame(this._rafId);
      this._rafId = null;
    }
    document.removeEventListener('visibilitychange', this._boundVisibilityChange);
  }

  /**
   * Check if the timer is currently running.
   * @returns {boolean}
   */
  isRunning() {
    return this._running;
  }

  /**
   * Internal tick handler called by requestAnimationFrame.
   * @param {number} timestamp - DOMHighResTimeStamp from rAF
   */
  _tick(timestamp) {
    if (!this._running) return;

    const delta = timestamp - this._lastTimestamp;
    this._lastTimestamp = timestamp;

    // Clamp delta to prevent huge jumps (e.g., after returning from background)
    // Max delta of 1 second to catch up gradually
    const clampedDelta = Math.min(delta, 1000);

    if (this._onTick && clampedDelta > 0) {
      this._onTick(clampedDelta);
    }

    this._rafId = requestAnimationFrame(this._boundTick);
  }

  /**
   * Handle visibility change to account for time when tab was hidden.
   * When tab becomes visible again, calculate actual elapsed time.
   */
  _handleVisibilityChange() {
    if (!this._running) return;

    if (document.visibilityState === 'visible') {
      // Cancel any pending rAF to prevent double-delivery of time
      if (this._rafId !== null) {
        cancelAnimationFrame(this._rafId);
        this._rafId = null;
      }

      // Use wall-clock (Date.now) for elapsed time while hidden.
      // performance.now() can freeze on mobile browsers when the OS
      // suspends the tab, but Date.now() always reflects real time.
      const now = Date.now();
      const delta = now - this._hiddenAtWallClock;
      this._lastTimestamp = performance.now();

      if (this._onTick && delta > 0) {
        this._onTick(delta);
      }

      // Re-schedule the rAF loop
      this._rafId = requestAnimationFrame(this._boundTick);
    } else {
      // Tab becoming hidden: stop rAF entirely (browsers throttle it
      // in background tabs, and the 1s clamp in _tick would lose time)
      // and record wall-clock time for accurate delta on return.
      if (this._rafId !== null) {
        cancelAnimationFrame(this._rafId);
        this._rafId = null;
      }
      this._hiddenAtWallClock = Date.now();
    }
  }

  /**
   * Clean up resources.
   */
  destroy() {
    this.stop();
    this._onTick = null;
  }
}

// --- js/engine/TimingMethod.js ---
/**
 * TimingMethod - Base class / interface for all timing methods.
 *
 * Each timing method implements specific rules for how time counts,
 * what happens on turn start/end, and when time expires.
 */

class TimingMethod {
  /**
   * @param {object} config - Period-specific configuration
   * @param {number} [config.timeMs] - Main time in milliseconds
   * @param {number} [config.delayMs] - Delay or bonus time per move
   * @param {number} [config.movesRequired] - Moves required to complete period (0 = until time expires)
   * @param {number} [config.byoMoments] - Number of byo-yomi moments
   * @param {number} [config.byoTimeMs] - Time per byo-yomi moment
   */
  constructor(config) {
    this.config = config || {};
  }

  /**
   * Called when a player's turn begins.
   * @param {import('../state/PlayerState.js').PlayerState} playerState
   */
  onTurnStart(playerState) {
    // Override in subclasses
  }

  /**
   * Called each timer tick while this player's clock is running.
   * @param {number} deltaMs - Time elapsed since last tick
   * @param {import('../state/PlayerState.js').PlayerState} playerState
   * @returns {{ expired: boolean, remainingMs: number }} Result of the tick
   */
  onTick(deltaMs, playerState) {
    // Override in subclasses
    return { expired: false, remainingMs: playerState.timeMs };
  }

  /**
   * Called when a player's turn ends (they pressed the clock).
   * @param {import('../state/PlayerState.js').PlayerState} playerState
   */
  onTurnEnd(playerState) {
    // Override in subclasses
  }

  /**
   * Check if the player's time has expired.
   * @param {import('../state/PlayerState.js').PlayerState} playerState
   * @returns {boolean}
   */
  isExpired(playerState) {
    return playerState.timeMs <= 0;
  }

  /**
   * Get the display time for this player.
   * @param {import('../state/PlayerState.js').PlayerState} playerState
   * @returns {number} Time in milliseconds to display
   */
  getDisplayTime(playerState) {
    return Math.max(0, playerState.timeMs);
  }

  /**
   * Get the timing method type identifier.
   * @returns {string}
   */
  getType() {
    return 'TIME';
  }
}

// --- js/engine/methods/TimeMethod.js ---
/**
 * TimeMethod - Guillotine / Sudden Death timing
 *
 * Simple countdown to zero. No bonus or delay per move.
 * When a player reaches 0:00, a flag appears.
 */


class TimeMethod extends TimingMethod {
  constructor(config) {
    super(config);
  }

  onTurnStart(playerState) {
    // No special action on turn start for simple time
  }

  onTick(deltaMs, playerState) {
    playerState.timeMs -= deltaMs;

    if (playerState.timeMs <= 0) {
      playerState.timeMs = 0;
      return { expired: true, remainingMs: 0 };
    }

    return { expired: false, remainingMs: playerState.timeMs };
  }

  onTurnEnd(playerState) {
    // No bonus or delay to apply
  }

  isExpired(playerState) {
    return playerState.timeMs <= 0;
  }

  getType() {
    return TimingMethodType.TIME;
  }
}

// --- js/engine/methods/FischerMethod.js ---
/**
 * FischerMethod - Fischer Bonus timing
 *
 * A fixed bonus time is added AFTER each move (including the first move).
 * Players can accumulate time by playing faster than the bonus.
 * FIDE rules: clock freezes when reaching 0:00 in final period.
 * FREEZE is ON by default.
 */


class FischerMethod extends TimingMethod {
  /**
   * @param {object} config
   * @param {number} config.timeMs - Main time
   * @param {number} config.delayMs - Bonus time per move (Fischer increment)
   * @param {number} [config.movesRequired=0] - Moves to complete period (0 = until time expires)
   */
  constructor(config) {
    super(config);
    this.bonusMs = config.delayMs || 0;
    this.movesRequired = config.movesRequired || 0;
  }

  onTurnStart(playerState) {
    // Fischer bonus is added at the END of each move, not the start.
    // However, for the very first move of a period (FIDE rules),
    // the bonus is already included in the initial time setup.
    // The bonus for move N is added when move N ends (onTurnEnd).
  }

  onTick(deltaMs, playerState) {
    playerState.timeMs -= deltaMs;

    if (playerState.timeMs <= 0) {
      playerState.timeMs = 0;
      return { expired: true, remainingMs: 0 };
    }

    return { expired: false, remainingMs: playerState.timeMs };
  }

  onTurnEnd(playerState) {
    // Do not add bonus if player has already expired
    if (playerState.timeMs <= 0) return;
    // Add Fischer bonus after each move
    playerState.timeMs += this.bonusMs;
  }

  /**
   * Check if the period is complete based on move count.
   * @param {import('../../state/PlayerState.js').PlayerState} playerState
   * @returns {boolean} Whether the required moves have been completed
   */
  /**
   * Check if the period is complete based on move count.
   * @param {import('../../state/PlayerState.js').PlayerState} playerState
   * @param {number} [periodStartMoves=0] - Moves at start of this period
   * @returns {boolean} Whether the required moves have been completed
   */
  isPeriodCompleteByMoves(playerState, periodStartMoves = 0) {
    if (this.movesRequired <= 0) return false;
    return (playerState.moves - periodStartMoves) >= this.movesRequired;
  }

  isExpired(playerState) {
    return playerState.timeMs <= 0;
  }

  getType() {
    return TimingMethodType.FISCHER;
  }
}

// --- js/engine/methods/BronsteinDelayMethod.js ---
/**
 * BronsteinDelayMethod - Bronstein Delay timing
 *
 * Delay time is conceptually added to main time before the move.
 * If player uses less time than delay: clock resets to start-of-turn value.
 * If player uses more: only the delay amount is recovered.
 * Total time can NEVER exceed the amount at start of the move (no accumulation).
 * FREEZE is ON by default.
 */


class BronsteinDelayMethod extends TimingMethod {
  /**
   * @param {object} config
   * @param {number} config.timeMs - Main time
   * @param {number} config.delayMs - Delay time per move
   */
  constructor(config) {
    super(config);
    this.delayMs = config.delayMs || 0;
  }

  onTurnStart(playerState) {
    // Record time at start of turn
    playerState.turnStartTimeMs = playerState.timeMs;
  }

  onTick(deltaMs, playerState) {
    playerState.timeMs -= deltaMs;

    if (playerState.timeMs <= 0) {
      playerState.timeMs = 0;
      return { expired: true, remainingMs: 0 };
    }

    return { expired: false, remainingMs: playerState.timeMs };
  }

  onTurnEnd(playerState) {
    // Do not compensate if player has already expired
    if (playerState.timeMs <= 0) return;
    // Guard against uninitialized turnStartTimeMs
    if (playerState.turnStartTimeMs <= 0) return;

    // Calculate time used this turn
    const timeUsed = playerState.turnStartTimeMs - playerState.timeMs;

    // Add back the minimum of delay and time used
    const compensation = Math.min(this.delayMs, Math.max(0, timeUsed));
    playerState.timeMs += compensation;

    // Ensure time never exceeds start-of-turn value
    if (playerState.timeMs > playerState.turnStartTimeMs) {
      playerState.timeMs = playerState.turnStartTimeMs;
    }
  }

  isExpired(playerState) {
    return playerState.timeMs <= 0;
  }

  getType() {
    return TimingMethodType.DELAY;
  }
}

// --- js/engine/methods/UsDelayMethod.js ---
/**
 * UsDelayMethod - US Delay timing
 *
 * At the start of each turn, a separate delay countdown runs first.
 * Main time does not count down until the delay reaches zero.
 * The delay countdown is shown in a separate display area.
 * Functionally identical outcome to Bronstein, but displayed differently.
 * FREEZE is OFF by default.
 */


class UsDelayMethod extends TimingMethod {
  /**
   * @param {object} config
   * @param {number} config.timeMs - Main time
   * @param {number} config.delayMs - Delay time per move
   */
  constructor(config) {
    super(config);
    this.delayMs = config.delayMs || 0;
  }

  onTurnStart(playerState) {
    // Reset delay countdown at start of each turn
    playerState.delayRemainingMs = this.delayMs;
    playerState.inDelay = true;
  }

  onTick(deltaMs, playerState) {
    if (playerState.inDelay) {
      // Delay phase: count down the delay first
      playerState.delayRemainingMs -= deltaMs;

      if (playerState.delayRemainingMs <= 0) {
        // Delay expired, remaining delta goes to main time
        const overflow = -playerState.delayRemainingMs;
        playerState.delayRemainingMs = 0;
        playerState.inDelay = false;

        // Apply overflow to main time
        if (overflow > 0) {
          playerState.timeMs -= overflow;
        }
      }
    } else {
      // Main time phase
      playerState.timeMs -= deltaMs;
    }

    if (playerState.timeMs <= 0) {
      playerState.timeMs = 0;
      return { expired: true, remainingMs: 0 };
    }

    return { expired: false, remainingMs: playerState.timeMs };
  }

  onTurnEnd(playerState) {
    // Clear delay state
    playerState.inDelay = false;
    playerState.delayRemainingMs = 0;
  }

  isExpired(playerState) {
    return playerState.timeMs <= 0;
  }

  getDisplayTime(playerState) {
    return Math.max(0, playerState.timeMs);
  }

  getType() {
    return TimingMethodType.US_DELAY;
  }
}

// --- js/engine/methods/ByoYomiMethod.js ---
/**
 * ByoYomiMethod - Japanese Byo-yomi timing
 *
 * Used primarily in Go and Shogi. Each player gets a fixed amount of time
 * per move in byo-yomi. If completed within time, clock resets to start value.
 * If time expires, a non-blinking flag is shown and byo-yomi reloads.
 *
 * Tournament variant: multiple byo-yomi periods (moments).
 * Display shows TOTAL remaining time (moments * timePerMoment).
 * Sound ON by default.
 */


class ByoYomiMethod extends TimingMethod {
  /**
   * @param {object} config
   * @param {number} config.byoTimeMs - Time per byo-yomi moment
   * @param {number} config.byoMoments - Number of byo-yomi moments (max 99, 0 = infinite repeating)
   */
  constructor(config) {
    super(config);
    this.byoTimeMs = config.byoTimeMs || 0;
    this.byoMoments = config.byoMoments || 0;
    /** @type {number} Moments remaining at the start of the current turn */
    this._momentsAtTurnStart = 0;
  }

  onTurnStart(playerState) {
    // Track moments at the start of turn for proper reset on turn end
    this._momentsAtTurnStart = playerState.byoMomentsRemaining;
  }

  onTick(deltaMs, playerState) {
    playerState.timeMs -= deltaMs;

    if (playerState.timeMs <= 0) {
      let momentExpired = false;

      if (this.byoMoments === 0) {
        // Infinite repeating: always reload, account for overflow
        const overflow = -playerState.timeMs;
        playerState.timeMs = this.byoTimeMs - overflow;
        if (playerState.timeMs <= 0) playerState.timeMs = 1; // Prevent immediate re-expiry
        return { expired: false, remainingMs: playerState.timeMs, momentExpired: true };
      }

      // Multiple moments: consume moments in a loop to handle large deltas
      while (playerState.timeMs <= 0 && playerState.byoMomentsRemaining > 0) {
        playerState.byoMomentsRemaining--;
        momentExpired = true;

        if (playerState.byoMomentsRemaining <= 0) {
          // All moments exhausted
          playerState.timeMs = 0;
          return { expired: true, remainingMs: 0 };
        }

        // Reload with overflow carried into next moment
        playerState.timeMs += this.byoTimeMs;
      }

      if (playerState.timeMs <= 0) {
        playerState.timeMs = 0;
        return { expired: true, remainingMs: 0 };
      }

      if (momentExpired) {
        return { expired: false, remainingMs: playerState.timeMs, momentExpired: true };
      }
    }

    return { expired: false, remainingMs: playerState.timeMs };
  }

  onTurnEnd(playerState) {
    // If the move was completed within time and no moments were consumed,
    // reset to the current moment's full time
    if (playerState.timeMs > 0) {
      const momentsConsumed = (this._momentsAtTurnStart || 0) -
        (this.byoMoments === 0 ? (this._momentsAtTurnStart || 0) : playerState.byoMomentsRemaining);
      if (momentsConsumed <= 0) {
        // No moments consumed during this turn — reset current moment time
        playerState.timeMs = this.byoTimeMs;
      }
      // If moments were consumed, keep the current remaining time
      // (player used part of a new moment, don't give it back)
    }
  }

  /**
   * Calculate the total display time based on remaining moments.
   * Display shows total time = moments * timePerMoment
   * @param {import('../../state/PlayerState.js').PlayerState} playerState
   * @returns {number}
   */
  _getTotalDisplayTime(playerState) {
    if (this.byoMoments === 0) {
      // Infinite: show single moment time
      return this.byoTimeMs;
    }
    // Show single moment time (moments count shown separately)
    return this.byoTimeMs;
  }

  getDisplayTime(playerState) {
    return Math.max(0, playerState.timeMs);
  }

  isExpired(playerState) {
    if (this.byoMoments === 0) return false; // Infinite never truly expires
    return playerState.timeMs <= 0 && playerState.byoMomentsRemaining <= 0;
  }

  getType() {
    return TimingMethodType.BYO_YOMI;
  }
}

// --- js/engine/methods/CanadianByoYomiMethod.js ---
/**
 * CanadianByoYomiMethod - Canadian Byo-yomi timing
 *
 * A fixed number of moves must be completed within the byo-yomi time.
 * Time resets when required moves are played (player must trigger reload).
 * Cannot save time by playing faster (time always resets to full).
 * Max byo-yomi time: 9:59.
 * Sound ON by default.
 */


class CanadianByoYomiMethod extends TimingMethod {
  /**
   * @param {object} config
   * @param {number} config.byoTimeMs - Total time for the move group (max 599000ms = 9:59)
   * @param {number} [config.movesRequired] - Number of moves required (determined by game rules, not set on clock)
   */
  constructor(config) {
    super(config);
    this.byoTimeMs = Math.min(config.byoTimeMs || 0, 599000);
    this.movesRequired = config.movesRequired || 0;
    /** @type {number} Moves made in current byo-yomi period */
    this._movesInPeriod = 0;
  }

  onTurnStart(playerState) {
    // No special action on turn start
  }

  onTick(deltaMs, playerState) {
    playerState.timeMs -= deltaMs;

    if (playerState.timeMs <= 0) {
      // Time expired - flag shown but reload still possible
      playerState.timeMs = 0;
      return { expired: true, remainingMs: 0 };
    }

    return { expired: false, remainingMs: playerState.timeMs };
  }

  onTurnEnd(playerState) {
    this._movesInPeriod++;
  }

  /**
   * Reload the byo-yomi time (triggered by 3-second hold on back button).
   * Resets time to full byo-yomi time and move counter.
   * @param {import('../../state/PlayerState.js').PlayerState} playerState
   */
  reload(playerState) {
    playerState.timeMs = this.byoTimeMs;
    this._movesInPeriod = 0;
  }

  /**
   * Get the number of moves made in the current byo-yomi period.
   * @returns {number}
   */
  getMovesInPeriod() {
    return this._movesInPeriod;
  }

  /**
   * Reset moves in period counter.
   */
  resetMovesInPeriod() {
    this._movesInPeriod = 0;
  }

  isExpired(playerState) {
    return playerState.timeMs <= 0;
  }

  getType() {
    return TimingMethodType.CANADIAN_BYO;
  }
}

// --- js/engine/methods/UpcountMethod.js ---
/**
 * UpcountMethod - Upcount timing (used in Scrabble)
 *
 * Time counts UP from 0:00 instead of counting down.
 * Used to track overtime for penalty point calculation.
 * No configurable settings. Can only be set as the last period.
 */


class UpcountMethod extends TimingMethod {
  constructor(config) {
    super(config || {});
  }

  onTurnStart(playerState) {
    // No special action
  }

  onTick(deltaMs, playerState) {
    // Count UP instead of down
    playerState.timeMs += deltaMs;

    // Upcount never expires
    return { expired: false, remainingMs: playerState.timeMs };
  }

  onTurnEnd(playerState) {
    // No special action
  }

  isExpired(_playerState) {
    // Upcount never expires
    return false;
  }

  getDisplayTime(playerState) {
    return Math.max(0, playerState.timeMs);
  }

  getType() {
    return TimingMethodType.UPCOUNT;
  }
}

// --- js/engine/PeriodManager.js ---
/**
 * PeriodManager - Manages multi-period transitions
 *
 * Handles up to 4 periods per player. Manages transitions when time expires
 * or move count is reached. Handles the complex logic of:
 * - Adding next period time to both players on expiry
 * - Move-based transitions (per player independently)
 * - Bonus/delay difference calculations on transition
 * - Flag display logic
 */


class PeriodManager {
  /**
   * @param {import('../state/GameState.js').GameState} gameState
   */
  constructor(gameState) {
    this.gameState = gameState;

    /** @type {Map<string, import('./TimingMethod.js').TimingMethod>} Active timing method per player side */
    this.activeMethods = new Map();

    /** @type {number} Track moves at start of period for move-based transitions */
    this._periodStartMoves = { left: 0, right: 0 };
  }

  /**
   * Create a TimingMethod instance from a period configuration.
   * @param {object} periodConfig
   * @returns {import('./TimingMethod.js').TimingMethod}
   */
  static createMethod(periodConfig) {
    switch (periodConfig.method) {
      case TimingMethodType.TIME:
        return new TimeMethod(periodConfig);
      case TimingMethodType.FISCHER:
        return new FischerMethod(periodConfig);
      case TimingMethodType.DELAY:
        return new BronsteinDelayMethod(periodConfig);
      case TimingMethodType.US_DELAY:
        return new UsDelayMethod(periodConfig);
      case TimingMethodType.BYO_YOMI:
        return new ByoYomiMethod(periodConfig);
      case TimingMethodType.CANADIAN_BYO:
        return new CanadianByoYomiMethod(periodConfig);
      case TimingMethodType.UPCOUNT:
        return new UpcountMethod(periodConfig);
      default:
        return new TimeMethod(periodConfig);
    }
  }

  /**
   * Initialize timing methods for both players based on current game config.
   */
  init() {
    const config = this.gameState.optionConfig;
    if (!config || !config.periods || !config.periods.length) return;

    this.activeMethods.clear();
    const firstPeriod = config.periods[0];
    this.activeMethods.set('left', PeriodManager.createMethod(firstPeriod));
    this.activeMethods.set('right', PeriodManager.createMethod(firstPeriod));
    this._periodStartMoves = { left: 0, right: 0 };
  }

  /**
   * Get the active timing method for a player.
   * @param {string} side
   * @returns {import('./TimingMethod.js').TimingMethod|null}
   */
  getMethod(side) {
    return this.activeMethods.get(side) || null;
  }

  /**
   * Handle turn start for a player.
   * @param {string} side
   */
  onTurnStart(side) {
    const method = this.getMethod(side);
    const player = this.gameState.getPlayer(side);
    if (method && player) {
      method.onTurnStart(player);
    }
  }

  /**
   * Handle a timer tick for the active player.
   * @param {number} deltaMs
   * @param {string} side
   * @returns {{ expired: boolean, periodTransition: boolean }}
   */
  onTick(deltaMs, side) {
    const method = this.getMethod(side);
    const player = this.gameState.getPlayer(side);

    if (!method || !player) {
      return { expired: false, periodTransition: false };
    }

    const result = method.onTick(deltaMs, player);

    if (result.expired) {
      return this._handleExpiry(side);
    }

    // Check for move-based period transition (Fischer with movesRequired > 0)
    if (method instanceof FischerMethod && method.isPeriodCompleteByMoves(player, this._periodStartMoves[side] || 0)) {
      return this._transitionToNextPeriod(side, true);
    }

    return { expired: false, periodTransition: false };
  }

  /**
   * Handle turn end for a player.
   * @param {string} side
   */
  onTurnEnd(side) {
    const method = this.getMethod(side);
    const player = this.gameState.getPlayer(side);
    if (method && player) {
      method.onTurnEnd(player);
    }
  }

  /**
   * Handle time expiry for a player.
   * @param {string} side
   * @returns {{ expired: boolean, periodTransition: boolean }}
   */
  _handleExpiry(side) {
    const player = this.gameState.getPlayer(side);
    const isLastPeriod = this.gameState.isInFinalPeriod(side);

    if (isLastPeriod) {
      // Final period: blinking flag, game over (or freeze)
      player.setFlag(FlagState.BLINKING);
      return { expired: true, periodTransition: false };
    }

    // Non-final period: transition to next period
    return this._transitionToNextPeriod(side, false);
  }

  /**
   * Transition a player (or both) to the next period.
   * @param {string} side - The player transitioning
   * @param {boolean} moveBasedTransition - Whether this is a move-based transition
   * @returns {{ expired: boolean, periodTransition: boolean }}
   */
  _transitionToNextPeriod(side, moveBasedTransition) {
    const config = this.gameState.optionConfig;
    const player = this.gameState.getPlayer(side);
    const opponent = this.gameState.getOpponent(side);

    const currentPeriodIdx = player.currentPeriod;
    const nextPeriodIdx = currentPeriodIdx + 1;

    if (nextPeriodIdx >= config.periods.length) {
      // No more periods (shouldn't happen if isInFinalPeriod check worked)
      player.setFlag(FlagState.BLINKING);
      return { expired: true, periodTransition: false };
    }

    const currentPeriodConfig = config.periods[currentPeriodIdx];
    const nextPeriodConfig = config.periods[nextPeriodIdx];

    // Skip END markers
    if (nextPeriodConfig.method === TimingMethodType.END) {
      player.setFlag(FlagState.BLINKING);
      return { expired: true, periodTransition: false };
    }

    if (moveBasedTransition) {
      // Move-based: transition per player independently
      this._transitionPlayerToPeriod(side, nextPeriodIdx, currentPeriodConfig, nextPeriodConfig);
    } else {
      // Time-based: non-blinking flag, add time to BOTH players simultaneously
      player.setFlag(FlagState.NON_BLINKING);

      // Transition this player
      this._transitionPlayerToPeriod(side, nextPeriodIdx, currentPeriodConfig, nextPeriodConfig);

      // Also add time to opponent if they haven't transitioned yet
      if (opponent.currentPeriod === currentPeriodIdx) {
        this._transitionPlayerToPeriod(
          side === 'left' ? 'right' : 'left',
          nextPeriodIdx,
          currentPeriodConfig,
          nextPeriodConfig,
        );
      }
    }

    return { expired: false, periodTransition: true };
  }

  /**
   * Transition a single player to a new period.
   * @param {string} side
   * @param {number} periodIdx
   * @param {object} oldConfig
   * @param {object} newConfig
   */
  _transitionPlayerToPeriod(side, periodIdx, oldConfig, newConfig) {
    const player = this.gameState.getPlayer(side);

    // Update period index
    player.currentPeriod = periodIdx;

    // Handle time assignment based on the new method type
    const newMethod = newConfig.method;

    if (newMethod === TimingMethodType.BYO_YOMI) {
      // Byo-yomi: set up moments and reset time to byo time
      player.byoMomentsRemaining = newConfig.byoMoments || 0;
      player.byoMomentTimeMs = newConfig.byoTimeMs || 0;
      player.timeMs = newConfig.byoTimeMs || 0;
    } else if (newMethod === TimingMethodType.CANADIAN_BYO) {
      // Canadian byo-yomi: reset time to byo time
      player.timeMs = newConfig.byoTimeMs || 0;
    } else if (newMethod === TimingMethodType.UPCOUNT) {
      // Upcount: start counting up from zero
      player.timeMs = 0;
    } else {
      // TIME, FISCHER, DELAY, US_DELAY: add new period's main time
      player.timeMs += newConfig.timeMs || 0;
    }

    // Reset delay state for the new period
    player.delayRemainingMs = 0;
    player.inDelay = false;

    // Create new timing method instance
    this.activeMethods.set(side, PeriodManager.createMethod(newConfig));

    // Reset period start moves
    this._periodStartMoves[side] = player.moves;
  }

  /**
   * Get the current timing method type for a player.
   * @param {string} side
   * @returns {string}
   */
  getMethodType(side) {
    const method = this.getMethod(side);
    return method ? method.getType() : TimingMethodType.TIME;
  }

  /**
   * Trigger Canadian Byo-yomi reload for a player.
   * @param {string} side
   * @returns {boolean} Whether reload was performed
   */
  reloadCanadianByo(side) {
    const method = this.getMethod(side);
    const player = this.gameState.getPlayer(side);

    if (method instanceof CanadianByoYomiMethod) {
      method.reload(player);
      player.clearFlag();
      return true;
    }
    return false;
  }
}

// --- js/engine/MoveCounter.js ---
/**
 * MoveCounter - Tracks move counts per player
 *
 * In chess: White and Black alternate moves. Move numbers are tracked
 * per the convention where one "move" = one player's action.
 * The clock counts button presses as moves.
 */

class MoveCounter {
  constructor() {
    /** @type {number} */
    this.leftMoves = 0;
    /** @type {number} */
    this.rightMoves = 0;
  }

  /**
   * Record a move for a player.
   * @param {string} side - 'left' or 'right'
   */
  recordMove(side) {
    if (side === 'left') {
      this.leftMoves++;
    } else {
      this.rightMoves++;
    }
  }

  /**
   * Get move count for a player.
   * @param {string} side
   * @returns {number}
   */
  getMoves(side) {
    return side === 'left' ? this.leftMoves : this.rightMoves;
  }

  /**
   * Set move count for a player (used in correction mode).
   * @param {string} side
   * @param {number} count
   */
  setMoves(side, count) {
    if (side === 'left') {
      this.leftMoves = Math.max(0, count);
    } else {
      this.rightMoves = Math.max(0, count);
    }
  }

  /**
   * Reset all move counts.
   */
  reset() {
    this.leftMoves = 0;
    this.rightMoves = 0;
  }

  /**
   * Get the chess move number (1-based, increments every 2 half-moves).
   * @param {string} whiteColor - Which side plays white ('left' or 'right')
   * @returns {number} Chess move number
   */
  getChessMoveNumber(whiteColor) {
    const whiteMoves = whiteColor === 'left' ? this.leftMoves : this.rightMoves;
    // Chess move number = white's move count (white moves first)
    return whiteMoves;
  }
}

// --- js/utils/TimeFormatter.js ---
/**
 * TimeFormatter - Converts milliseconds to display strings
 */

/**
 * Format milliseconds to a display string.
 * Display format rules:
 * - >= 1 hour:   H:MM:SS
 * - >= 20 min:   MM:SS
 * - >= 1 min:    M:SS
 * - < 1 min:     M:SS.d (with tenths)
 * - Negative:    0:00
 *
 * @param {number} ms - Time in milliseconds
 * @param {boolean} [showTenths=true] - Whether to show tenths when under 1 minute
 * @returns {string} Formatted time string
 */
function formatTime(ms, showTenths = true) {
  if (ms < 0) ms = 0;

  const totalSeconds = Math.floor(ms / 1000);
  const tenths = Math.floor((ms % 1000) / 100);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;

  const pad2 = (n) => String(n).padStart(2, '0');

  if (hours > 0) {
    return `${hours}:${pad2(minutes)}:${pad2(seconds)}`;
  }

  if (totalSeconds < 60 && showTenths) {
    return `${minutes}:${pad2(seconds)}.${tenths}`;
  }

  return `${minutes}:${pad2(seconds)}`;
}

/**
 * Format milliseconds for correction mode (always show all digits).
 * Format: H:MM:SS
 *
 * @param {number} ms - Time in milliseconds
 * @returns {string} Formatted time string with all digits
 */
function formatTimeFull(ms) {
  if (ms < 0) ms = 0;

  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;

  const pad2 = (n) => String(n).padStart(2, '0');

  return `${hours}:${pad2(minutes)}:${pad2(seconds)}`;
}

/**
 * Parse a time string (H:MM:SS or M:SS) back to milliseconds.
 *
 * @param {string} timeStr - Time string
 * @returns {number} Time in milliseconds
 */
function parseTime(timeStr) {
  if (!timeStr || typeof timeStr !== 'string') return 0;
  const parts = timeStr.split(':').map(Number);
  if (parts.some(isNaN)) return 0;
  if (parts.length === 3) {
    return (parts[0] * 3600 + parts[1] * 60 + parts[2]) * 1000;
  }
  if (parts.length === 2) {
    return (parts[0] * 60 + parts[1]) * 1000;
  }
  return 0;
}

/**
 * Format milliseconds to a short description string (for preset display).
 * Examples: "5 min", "1h 30m", "2h", "30 sec"
 *
 * @param {number} ms - Time in milliseconds
 * @returns {string} Human-readable short time
 */
function formatTimeShort(ms) {
  if (!ms || ms < 0 || isNaN(ms)) return '0s';
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;

  const parts = [];
  if (hours > 0) parts.push(`${hours}h`);
  if (minutes > 0) parts.push(`${minutes}m`);
  if (seconds > 0 && hours === 0) parts.push(`${seconds}s`);
  if (parts.length === 0) return '0s';

  return parts.join(' ');
}

// --- js/ui/ClockDisplay.js ---
/**
 * ClockDisplay - Renders the clock face for both players
 *
 * Displays:
 * - Large time digits for each player
 * - Active/inactive player highlighting
 * - Flag indicators
 * - Color indicators (white/black piece)
 * - Move count (on demand)
 * - Byo-yomi moments remaining
 */


class ClockDisplay {
  /**
   * @param {HTMLElement} containerEl - Main container element
   */
  constructor(containerEl) {
    this._container = containerEl;

    /** @type {HTMLElement} */
    this._leftClockEl = null;
    /** @type {HTMLElement} */
    this._rightClockEl = null;
    /** @type {HTMLElement} */
    this._leftTimeEl = null;
    /** @type {HTMLElement} */
    this._rightTimeEl = null;
    /** @type {HTMLElement} */
    this._leftFlagEl = null;
    /** @type {HTMLElement} */
    this._rightFlagEl = null;
    /** @type {HTMLElement} */
    this._leftColorEl = null;
    /** @type {HTMLElement} */
    this._rightColorEl = null;
    /** @type {HTMLElement} */
    this._leftMovesEl = null;
    /** @type {HTMLElement} */
    this._rightMovesEl = null;
    /** @type {HTMLElement} */
    this._leftByoEl = null;
    /** @type {HTMLElement} */
    this._rightByoEl = null;
    /** @type {HTMLElement} */
    this._leftGhostEl = null;
    /** @type {HTMLElement} */
    this._rightGhostEl = null;
    /** @type {HTMLElement} */
    this._leftLedEl = null;
    /** @type {HTMLElement} */
    this._rightLedEl = null;

    // Auto-size state
    this._leftTextLen = 0;
    this._rightTextLen = 0;
    this._resizeObserver = null;

    // Dirty-checking cache for update()
    this._prev = {};

    // ResizeObserver dimension tracking
    this._leftDims = { w: 0, h: 0 };
    this._rightDims = { w: 0, h: 0 };

    // Font size cache: "w,h,len" -> fontSize
    this._fontSizeCache = new Map();

    this._build();
  }

  _build() {
    this._container.innerHTML = '';
    this._container.classList.add('clock-container');

    // Left clock
    this._leftClockEl = this._createClockFace('left');
    // Right clock
    this._rightClockEl = this._createClockFace('right');

    this._container.appendChild(this._leftClockEl);
    this._container.appendChild(this._rightClockEl);

    // Store references
    this._leftTimeEl = this._leftClockEl.querySelector('.clock-time');
    this._rightTimeEl = this._rightClockEl.querySelector('.clock-time');
    this._leftFlagEl = this._leftClockEl.querySelector('.clock-flag');
    this._rightFlagEl = this._rightClockEl.querySelector('.clock-flag');
    this._leftColorEl = this._leftClockEl.querySelector('.clock-color');
    this._rightColorEl = this._rightClockEl.querySelector('.clock-color');
    this._leftMovesEl = this._leftClockEl.querySelector('.clock-moves');
    this._rightMovesEl = this._rightClockEl.querySelector('.clock-moves');
    this._leftByoEl = this._leftClockEl.querySelector('.clock-byo');
    this._rightByoEl = this._rightClockEl.querySelector('.clock-byo');
    this._leftGhostEl = this._leftClockEl.querySelector('.clock-ghost');
    this._rightGhostEl = this._rightClockEl.querySelector('.clock-ghost');
    this._leftLedEl = this._leftClockEl.querySelector('.led-indicator');
    this._rightLedEl = this._rightClockEl.querySelector('.led-indicator');

    this._initAutoSize();
  }

  /**
   * Initialize auto-sizing with ResizeObserver.
   */
  _initAutoSize() {
    this._resizeObserver = new ResizeObserver((entries) => {
      let changed = false;
      for (const entry of entries) {
        const el = entry.target;
        const w = el.clientWidth;
        const h = el.clientHeight;
        const dims = el === this._leftClockEl ? this._leftDims : this._rightDims;
        if (w === dims.w && h === dims.h) continue;
        dims.w = w;
        dims.h = h;
        changed = true;
      }
      if (changed) this._syncFontSizes();
    });

    this._resizeObserver.observe(this._leftClockEl);
    this._resizeObserver.observe(this._rightClockEl);

    // Initial fit after layout
    requestAnimationFrame(() => {
      this._syncFontSizes();
    });
  }

  /**
   * Binary-search for the largest font-size that fits within the container.
   * Returns the computed size without applying it.
   * @param {HTMLElement} container - The clock face element
   * @param {HTMLElement} textEl - The time text element
   * @returns {number} The computed font size in px, or 0 if container has no size
   */
  _computeFitSize(container, textEl) {
    const containerW = container.clientWidth;
    const containerH = container.clientHeight;
    if (containerW === 0 || containerH === 0) return 0;

    const textLen = textEl.textContent.length;
    const cacheKey = `${containerW},${containerH},${textLen}`;
    const cached = this._fontSizeCache.get(cacheKey);
    if (cached !== undefined) return cached;

    const maxW = containerW * 0.9;
    const maxH = containerH * 0.5;

    let lo = 16;
    let hi = 500;

    while (hi - lo > 1) {
      const mid = Math.floor((lo + hi) / 2);
      textEl.style.fontSize = mid + 'px';
      if (textEl.scrollWidth <= maxW && textEl.scrollHeight <= maxH) {
        lo = mid;
      } else {
        hi = mid;
      }
    }

    this._fontSizeCache.set(cacheKey, lo);
    return lo;
  }

  /**
   * Apply a font size to a clock face's time and ghost elements.
   * @param {HTMLElement} container - The clock face element
   * @param {HTMLElement} textEl - The time text element
   * @param {number} size - Font size in px
   */
  _applyFontSize(container, textEl, size) {
    textEl.style.fontSize = size + 'px';
    const ghostEl = container.querySelector('.clock-ghost');
    if (ghostEl) ghostEl.style.fontSize = size + 'px';
  }

  /**
   * Compute optimal font sizes for both sides and apply the minimum
   * so both clocks always display at the same size.
   */
  _syncFontSizes() {
    const leftSize = this._computeFitSize(this._leftClockEl, this._leftTimeEl);
    const rightSize = this._computeFitSize(this._rightClockEl, this._rightTimeEl);
    if (leftSize === 0 || rightSize === 0) return;

    const size = Math.min(leftSize, rightSize);
    this._applyFontSize(this._leftClockEl, this._leftTimeEl, size);
    this._applyFontSize(this._rightClockEl, this._rightTimeEl, size);
  }

  /**
   * Clear the font size cache so sizes recompute on next sync.
   */
  clearFontSizeCache() {
    this._fontSizeCache.clear();
  }

  /**
   * Create a single clock face element.
   * @param {string} side
   * @returns {HTMLElement}
   */
  _createClockFace(side) {
    const clock = document.createElement('div');
    clock.className = `clock-face clock-${side}`;
    clock.setAttribute('data-side', side);
    clock.setAttribute('role', 'button');
    clock.setAttribute('tabindex', '0');
    clock.setAttribute('aria-label', `${side} player clock`);

    // Flag indicator
    const flag = document.createElement('div');
    flag.className = 'clock-flag flag-hidden';
    flag.textContent = '\u2691'; // Flag

    // LED indicator
    const led = document.createElement('div');
    led.className = 'led-indicator';

    // Color indicator
    const color = document.createElement('div');
    color.className = 'clock-color';

    // Header row (flag + LED + color)
    const header = document.createElement('div');
    header.className = 'clock-header';
    header.appendChild(flag);
    header.appendChild(led);
    header.appendChild(color);

    // Time wrapper (holds ghost + real time)
    const timeWrapper = document.createElement('div');
    timeWrapper.className = 'time-wrapper';

    // Ghost segments (unlit LCD segments behind real digits)
    const ghost = document.createElement('div');
    ghost.className = 'clock-ghost';
    ghost.textContent = '8:88';

    // Time display
    const time = document.createElement('div');
    time.className = 'clock-time';
    time.textContent = '0:00';

    timeWrapper.appendChild(ghost);
    timeWrapper.appendChild(time);

    // Footer row (moves + byo)
    const footer = document.createElement('div');
    footer.className = 'clock-footer';

    const moves = document.createElement('div');
    moves.className = 'clock-moves hidden';

    const byo = document.createElement('div');
    byo.className = 'clock-byo hidden';

    footer.appendChild(moves);
    footer.appendChild(byo);

    clock.appendChild(header);
    clock.appendChild(timeWrapper);
    clock.appendChild(footer);

    return clock;
  }

  /**
   * Get the flag elements for the FlagIndicator.
   * @returns {{ left: HTMLElement, right: HTMLElement }}
   */
  getFlagElements() {
    return {
      left: this._leftFlagEl,
      right: this._rightFlagEl,
    };
  }

  /**
   * Get clock face elements (for click/touch binding).
   * @returns {{ left: HTMLElement, right: HTMLElement }}
   */
  getClockFaces() {
    return {
      left: this._leftClockEl,
      right: this._rightClockEl,
    };
  }

  /**
   * Update the display for both players.
   * @param {object} state
   * @param {number} state.leftTimeMs
   * @param {number} state.rightTimeMs
   * @param {string} state.activePlayer - Player.LEFT, Player.RIGHT, or null
   * @param {string} state.gameStatus
   * @param {string} state.leftColor - 'white' or 'black'
   * @param {string} state.rightColor - 'white' or 'black'
   * @param {string} state.leftFlagState
   * @param {string} state.rightFlagState
   * @param {number} state.leftMoves
   * @param {number} state.rightMoves
   * @param {boolean} state.showMoves
   * @param {number} [state.leftByoMoments]
   * @param {number} [state.rightByoMoments]
   * @param {string} [state.leftMethod]
   * @param {string} [state.rightMethod]
   */
  update(state) {
    const p = this._prev;

    // Time display
    const leftIsUpcount = state.leftMethod === TimingMethodType.UPCOUNT;
    const rightIsUpcount = state.rightMethod === TimingMethodType.UPCOUNT;

    const leftText = formatTime(state.leftTimeMs, !leftIsUpcount);
    const rightText = formatTime(state.rightTimeMs, !rightIsUpcount);

    let needSync = false;

    if (leftText !== p.leftText) {
      this._leftTimeEl.textContent = leftText;
      p.leftText = leftText;

      // Re-fit text if length changed (e.g. "5:00" -> "4:59:59")
      if (leftText.length !== this._leftTextLen) {
        this._leftTextLen = leftText.length;
        this._leftGhostEl.textContent = this._toGhostText(leftText);
        needSync = true;
      }
    }

    if (rightText !== p.rightText) {
      this._rightTimeEl.textContent = rightText;
      p.rightText = rightText;

      if (rightText.length !== this._rightTextLen) {
        this._rightTextLen = rightText.length;
        this._rightGhostEl.textContent = this._toGhostText(rightText);
        needSync = true;
      }
    }

    if (needSync) this._syncFontSizes();

    // Active player highlighting
    const leftActive = state.activePlayer === Player.LEFT && state.gameStatus === GameStatus.RUNNING;
    const rightActive = state.activePlayer === Player.RIGHT && state.gameStatus === GameStatus.RUNNING;
    const leftPaused = state.gameStatus === GameStatus.PAUSED && state.activePlayer === Player.LEFT;
    const rightPaused = state.gameStatus === GameStatus.PAUSED && state.activePlayer === Player.RIGHT;

    if (leftActive !== p.leftActive) {
      this._leftClockEl.classList.toggle('active', leftActive);
      p.leftActive = leftActive;
    }
    if (rightActive !== p.rightActive) {
      this._rightClockEl.classList.toggle('active', rightActive);
      p.rightActive = rightActive;
    }
    if (leftPaused !== p.leftPaused) {
      this._leftClockEl.classList.toggle('paused', leftPaused);
      p.leftPaused = leftPaused;
    }
    if (rightPaused !== p.rightPaused) {
      this._rightClockEl.classList.toggle('paused', rightPaused);
      p.rightPaused = rightPaused;
    }

    // Color indicators
    if (state.leftColor !== p.leftColor) {
      this._leftColorEl.className = `clock-color piece-${state.leftColor}`;
      this._leftColorEl.setAttribute('aria-label', state.leftColor);
      p.leftColor = state.leftColor;
    }
    if (state.rightColor !== p.rightColor) {
      this._rightColorEl.className = `clock-color piece-${state.rightColor}`;
      this._rightColorEl.setAttribute('aria-label', state.rightColor);
      p.rightColor = state.rightColor;
    }

    // Flag states
    if (state.leftFlagState !== p.leftFlagState) {
      this._updateFlag(this._leftFlagEl, state.leftFlagState);
      p.leftFlagState = state.leftFlagState;
    }
    if (state.rightFlagState !== p.rightFlagState) {
      this._updateFlag(this._rightFlagEl, state.rightFlagState);
      p.rightFlagState = state.rightFlagState;
    }

    // Move count
    if (state.showMoves !== p.showMoves || state.leftMoves !== p.leftMoves || state.rightMoves !== p.rightMoves) {
      if (state.showMoves) {
        this._leftMovesEl.textContent = `Moves: ${state.leftMoves}`;
        this._leftMovesEl.classList.remove('hidden');
        this._rightMovesEl.textContent = `Moves: ${state.rightMoves}`;
        this._rightMovesEl.classList.remove('hidden');
      } else {
        this._leftMovesEl.classList.add('hidden');
        this._rightMovesEl.classList.add('hidden');
      }
      p.showMoves = state.showMoves;
      p.leftMoves = state.leftMoves;
      p.rightMoves = state.rightMoves;
    }

    // Byo-yomi moments
    if (state.leftByoMoments !== p.leftByoMoments) {
      if (state.leftByoMoments !== undefined && state.leftByoMoments > 0) {
        this._leftByoEl.textContent = `\u00D7${state.leftByoMoments}`;
        this._leftByoEl.classList.remove('hidden');
      } else {
        this._leftByoEl.classList.add('hidden');
      }
      p.leftByoMoments = state.leftByoMoments;
    }

    if (state.rightByoMoments !== p.rightByoMoments) {
      if (state.rightByoMoments !== undefined && state.rightByoMoments > 0) {
        this._rightByoEl.textContent = `\u00D7${state.rightByoMoments}`;
        this._rightByoEl.classList.remove('hidden');
      } else {
        this._rightByoEl.classList.add('hidden');
      }
      p.rightByoMoments = state.rightByoMoments;
    }

    // Frozen state - only mark the flagged player's clock as frozen
    const leftFrozen = state.gameStatus === GameStatus.FROZEN && state.leftFlagState !== FlagState.NONE;
    const rightFrozen = state.gameStatus === GameStatus.FROZEN && state.rightFlagState !== FlagState.NONE;
    if (leftFrozen !== p.leftFrozen) {
      this._leftClockEl.classList.toggle('frozen', leftFrozen);
      p.leftFrozen = leftFrozen;
    }
    if (rightFrozen !== p.rightFrozen) {
      this._rightClockEl.classList.toggle('frozen', rightFrozen);
      p.rightFrozen = rightFrozen;
    }

    // Expired warning (red time)
    const leftExpired = state.leftTimeMs <= 0 && !leftIsUpcount;
    const rightExpired = state.rightTimeMs <= 0 && !rightIsUpcount;
    if (leftExpired !== p.leftExpired) {
      this._leftTimeEl.classList.toggle('time-expired', leftExpired);
      p.leftExpired = leftExpired;
    }
    if (rightExpired !== p.rightExpired) {
      this._rightTimeEl.classList.toggle('time-expired', rightExpired);
      p.rightExpired = rightExpired;
    }

    // Low time warning
    const leftLow = state.leftTimeMs > 0 && state.leftTimeMs <= 10000 && !leftIsUpcount;
    const rightLow = state.rightTimeMs > 0 && state.rightTimeMs <= 10000 && !rightIsUpcount;
    if (leftLow !== p.leftLow) {
      this._leftTimeEl.classList.toggle('time-low', leftLow);
      p.leftLow = leftLow;
    }
    if (rightLow !== p.rightLow) {
      this._rightTimeEl.classList.toggle('time-low', rightLow);
      p.rightLow = rightLow;
    }
  }

  /**
   * Convert a time string to ghost text (all digits become 8).
   * e.g. "5:23" -> "8:88", "1:05:23" -> "8:88:88", "3:45.2" -> "8:88.8"
   * @param {string} timeText
   * @returns {string}
   */
  _toGhostText(timeText) {
    return timeText.replace(/\d/g, '8');
  }

  /**
   * Update a single flag element.
   * @param {HTMLElement} el
   * @param {string} flagState
   */
  _updateFlag(el, flagState) {
    el.classList.remove('flag-blinking', 'flag-solid', 'flag-hidden');
    switch (flagState) {
      case FlagState.BLINKING:
        el.classList.add('flag-blinking');
        break;
      case FlagState.NON_BLINKING:
        el.classList.add('flag-solid');
        break;
      default:
        el.classList.add('flag-hidden');
        break;
    }
  }
}

// --- js/ui/StatusBar.js ---
/**
 * StatusBar - Displays timing method, period, icons, option number
 *
 * Shows:
 * - Active timing method name per player
 * - Current period number per player
 * - Freeze icon (snowflake)
 * - Sound icon (musical note)
 * - Option number
 * - Play/Pause indicator
 */


class StatusBar {
  /**
   * @param {HTMLElement} containerEl - Status bar container element
   */
  constructor(containerEl) {
    this._el = containerEl;
    this._messageText = null;

    // Create sub-elements
    this._leftMethodEl = null;
    this._rightMethodEl = null;
    this._leftPeriodEl = null;
    this._rightPeriodEl = null;
    this._freezeIconEl = null;
    this._soundIconEl = null;
    this._optionEl = null;
    this._moveEl = null;
    this._stateEl = null;
    this._delayEl = null;

    // Dirty-checking cache for update()
    this._prev = {};

    this._build();
  }

  _build() {
    this._el.innerHTML = '';
    this._el.classList.add('status-bar');

    // Left side info
    const leftInfo = document.createElement('div');
    leftInfo.className = 'status-left';
    this._leftMethodEl = document.createElement('span');
    this._leftMethodEl.className = 'status-method';
    this._leftPeriodEl = document.createElement('span');
    this._leftPeriodEl.className = 'status-period';
    leftInfo.appendChild(this._leftMethodEl);
    leftInfo.appendChild(this._leftPeriodEl);

    // Center info
    const centerInfo = document.createElement('div');
    centerInfo.className = 'status-center';
    this._freezeIconEl = document.createElement('span');
    this._freezeIconEl.className = 'status-icon freeze-icon';
    this._freezeIconEl.textContent = '\u2744'; // Snowflake
    this._freezeIconEl.title = 'Freeze mode';
    this._freezeIconEl.setAttribute('role', 'img');
    this._freezeIconEl.setAttribute('aria-label', 'Freeze mode enabled');
    this._soundIconEl = document.createElement('span');
    this._soundIconEl.className = 'status-icon sound-icon';
    this._soundIconEl.textContent = '\u266B'; // Musical note
    this._soundIconEl.title = 'Sound enabled';
    this._soundIconEl.setAttribute('role', 'img');
    this._soundIconEl.setAttribute('aria-label', 'Sound enabled');
    this._optionEl = document.createElement('span');
    this._optionEl.className = 'status-option';
    this._moveEl = document.createElement('span');
    this._moveEl.className = 'status-move';
    this._stateEl = document.createElement('span');
    this._stateEl.className = 'status-state';
    this._delayEl = document.createElement('span');
    this._delayEl.className = 'status-delay';

    centerInfo.appendChild(this._freezeIconEl);
    centerInfo.appendChild(this._soundIconEl);
    centerInfo.appendChild(this._optionEl);
    centerInfo.appendChild(this._moveEl);
    centerInfo.appendChild(this._stateEl);
    centerInfo.appendChild(this._delayEl);

    // Right side info
    const rightInfo = document.createElement('div');
    rightInfo.className = 'status-right';
    this._rightMethodEl = document.createElement('span');
    this._rightMethodEl.className = 'status-method';
    this._rightPeriodEl = document.createElement('span');
    this._rightPeriodEl.className = 'status-period';
    rightInfo.appendChild(this._rightPeriodEl);
    rightInfo.appendChild(this._rightMethodEl);

    this._el.appendChild(leftInfo);
    this._el.appendChild(centerInfo);
    this._el.appendChild(rightInfo);
  }

  /**
   * Show a temporary message in the center area.
   * @param {string} text
   */
  showMessage(text) {
    this._messageText = text;
    if (this._optionEl) this._optionEl.textContent = '';
    if (this._moveEl) this._moveEl.textContent = '';
    if (this._stateEl) this._stateEl.textContent = text;
    if (this._delayEl) this._delayEl.classList.add('hidden');
    this._freezeIconEl.classList.add('hidden');
    this._soundIconEl.classList.add('hidden');
  }

  /**
   * Clear any temporary message.
   */
  clearMessage() {
    this._messageText = null;
  }

  /**
   * Update the status bar display.
   * @param {object} state
   * @param {string} state.leftMethod - Left player timing method type
   * @param {string} state.rightMethod - Right player timing method type
   * @param {number} state.leftPeriod - Left player current period (0-based)
   * @param {number} state.rightPeriod - Right player current period (0-based)
   * @param {number} state.totalPeriods - Total periods in config
   * @param {boolean} state.freezeEnabled
   * @param {boolean} state.soundEnabled
   * @param {number} state.optionNumber
   * @param {number} state.moveNumber - Current chess move number
   * @param {string} state.gameStatus
   * @param {number} [state.delayRemainingMs] - US-Delay countdown remaining
   */
  update(state) {
    // If a temporary message is showing, don't overwrite it
    if (this._messageText) return;

    const p = this._prev;

    // Method names
    const leftMethod = state.leftMethod || '';
    if (leftMethod !== p.leftMethod) {
      this._leftMethodEl.textContent = leftMethod;
      p.leftMethod = leftMethod;
    }
    const rightMethod = state.rightMethod || '';
    if (rightMethod !== p.rightMethod) {
      this._rightMethodEl.textContent = rightMethod;
      p.rightMethod = rightMethod;
    }

    // Period numbers (1-based display)
    const showPeriods = state.totalPeriods > 1;
    const leftPeriodText = showPeriods ? `P${state.leftPeriod + 1}` : '';
    const rightPeriodText = showPeriods ? `P${state.rightPeriod + 1}` : '';
    if (leftPeriodText !== p.leftPeriodText) {
      this._leftPeriodEl.textContent = leftPeriodText;
      p.leftPeriodText = leftPeriodText;
    }
    if (rightPeriodText !== p.rightPeriodText) {
      this._rightPeriodEl.textContent = rightPeriodText;
      p.rightPeriodText = rightPeriodText;
    }

    // Icons
    if (state.freezeEnabled !== p.freezeEnabled) {
      this._freezeIconEl.classList.toggle('hidden', !state.freezeEnabled);
      p.freezeEnabled = state.freezeEnabled;
    }
    if (state.soundEnabled !== p.soundEnabled) {
      this._soundIconEl.classList.toggle('hidden', !state.soundEnabled);
      p.soundEnabled = state.soundEnabled;
    }

    // Option number
    if (state.optionNumber !== p.optionNumber) {
      this._optionEl.textContent = `#${String(state.optionNumber).padStart(2, '0')}`;
      p.optionNumber = state.optionNumber;
    }

    // Move number
    if (state.moveNumber !== p.moveNumber) {
      this._moveEl.textContent = state.moveNumber > 0 ? `M${state.moveNumber}` : '';
      p.moveNumber = state.moveNumber;
    }

    // Game state indicator
    if (state.gameStatus !== p.gameStatus) {
      const stateIcons = {
        [GameStatus.IDLE]: '\u25B6',     // Play triangle
        [GameStatus.RUNNING]: '\u25B6',
        [GameStatus.PAUSED]: '\u23F8',   // Pause
        [GameStatus.FROZEN]: '\u26A0',   // Warning
        [GameStatus.CORRECTING]: '\u270E', // Pencil
      };
      this._stateEl.textContent = stateIcons[state.gameStatus] || '';
      p.gameStatus = state.gameStatus;
    }

    // Delay display
    if (state.delayRemainingMs !== p.delayRemainingMs) {
      if (state.delayRemainingMs !== undefined && state.delayRemainingMs > 0) {
        const delaySec = (state.delayRemainingMs / 1000).toFixed(1);
        this._delayEl.textContent = `DLY ${delaySec}`;
        this._delayEl.classList.remove('hidden');
      } else {
        this._delayEl.classList.add('hidden');
      }
      p.delayRemainingMs = state.delayRemainingMs;
    }
  }
}

// --- js/presets/presets.js ---
/**
 * Presets - All 24 pre-programmed timing options
 *
 * Each preset defines:
 * - name: Display name
 * - periods: Array of period configurations
 * - freezeDefault: Whether freeze mode is on by default
 * - soundDefault: Whether sound is on by default
 *
 * Period configuration:
 * - method: TimingMethodType
 * - timeMs: Main time in ms
 * - delayMs: Bonus/delay per move in ms
 * - movesRequired: Moves to complete period (0 = until time expires)
 * - byoTimeMs: Byo-yomi time per moment in ms
 * - byoMoments: Number of byo-yomi moments
 */


// Helper to convert minutes to ms
const min = (m) => m * 60 * 1000;
// Helper to convert hours to ms
const hr = (h) => h * 60 * 60 * 1000;
// Helper to convert seconds to ms
const sec = (s) => s * 1000;

const presets = [
  // ===== TIME Options (Single Period) - Options 01-05 =====
  {
    id: 1,
    name: '5 min',
    description: 'Blitz 5 minutes',
    periods: [{ method: TimingMethodType.TIME, timeMs: min(5) }],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 2,
    name: '10 min',
    description: 'Rapid 10 minutes',
    periods: [{ method: TimingMethodType.TIME, timeMs: min(10) }],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 3,
    name: '25 min',
    description: 'Rapid 25 minutes',
    periods: [{ method: TimingMethodType.TIME, timeMs: min(25) }],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 4,
    name: '1 hour',
    description: 'Classical 1 hour',
    periods: [{ method: TimingMethodType.TIME, timeMs: hr(1) }],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 5,
    name: '2 hours',
    description: 'Classical 2 hours',
    periods: [{ method: TimingMethodType.TIME, timeMs: hr(2) }],
    freezeDefault: false,
    soundDefault: false,
  },

  // ===== TIME Options (Multiple Periods) - Options 06-09 =====
  {
    id: 6,
    name: '2h + 30m',
    description: '2 hours then 30 minutes',
    periods: [
      { method: TimingMethodType.TIME, timeMs: hr(2) },
      { method: TimingMethodType.TIME, timeMs: min(30) },
    ],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 7,
    name: '2h + 1h',
    description: '2 hours then 1 hour',
    periods: [
      { method: TimingMethodType.TIME, timeMs: hr(2) },
      { method: TimingMethodType.TIME, timeMs: hr(1) },
    ],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 8,
    name: '2h + 1h + 30m',
    description: '2 hours, 1 hour, then 30 minutes',
    periods: [
      { method: TimingMethodType.TIME, timeMs: hr(2) },
      { method: TimingMethodType.TIME, timeMs: hr(1) },
      { method: TimingMethodType.TIME, timeMs: min(30) },
    ],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 9,
    name: '2h + 1h + 1h',
    description: '2 hours, 1 hour, then 1 hour',
    periods: [
      { method: TimingMethodType.TIME, timeMs: hr(2) },
      { method: TimingMethodType.TIME, timeMs: hr(1) },
      { method: TimingMethodType.TIME, timeMs: hr(1) },
    ],
    freezeDefault: false,
    soundDefault: false,
  },

  // ===== FISCHER Options - Options 10-14 =====
  {
    id: 10,
    name: '3+2 Fischer',
    description: '3 min + 2s/move bonus',
    periods: [
      { method: TimingMethodType.FISCHER, timeMs: min(3), delayMs: sec(2) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },
  {
    id: 11,
    name: '25+10 Fischer',
    description: '25 min + 10s/move bonus',
    periods: [
      { method: TimingMethodType.FISCHER, timeMs: min(25), delayMs: sec(10) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },
  {
    id: 12,
    name: '1h30+30s Fischer',
    description: '1h 30min + 30s/move bonus',
    periods: [
      { method: TimingMethodType.FISCHER, timeMs: hr(1) + min(30), delayMs: sec(30) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },
  {
    id: 13,
    name: '1h30+30m+30s Fischer',
    description: '1h30m + 30m (2nd period) + 30s/move bonus all periods',
    periods: [
      { method: TimingMethodType.FISCHER, timeMs: hr(1) + min(30), delayMs: sec(30) },
      { method: TimingMethodType.FISCHER, timeMs: min(30), delayMs: sec(30) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },
  {
    id: 14,
    name: '1h40+50m+15m+30s Fischer',
    description: '1h40m + 50m + 15m + 30s/move bonus all periods',
    periods: [
      { method: TimingMethodType.FISCHER, timeMs: hr(1) + min(40), delayMs: sec(30) },
      { method: TimingMethodType.FISCHER, timeMs: min(50), delayMs: sec(30) },
      { method: TimingMethodType.FISCHER, timeMs: min(15), delayMs: sec(30) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },

  // ===== DELAY (Bronstein) Options - Options 15-18 =====
  {
    id: 15,
    name: '25+10s Bronstein',
    description: '25 min + 10s/move Bronstein delay',
    periods: [
      { method: TimingMethodType.DELAY, timeMs: min(25), delayMs: sec(10) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },
  {
    id: 16,
    name: '1h55+5s Bronstein',
    description: '1h 55min + 5s/move Bronstein delay',
    periods: [
      { method: TimingMethodType.DELAY, timeMs: hr(1) + min(55), delayMs: sec(5) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },
  {
    id: 17,
    name: '2h+15m+30s Bronstein',
    description: '2h + 15m (2nd period) + 30s/move Bronstein delay all periods',
    periods: [
      { method: TimingMethodType.DELAY, timeMs: hr(2), delayMs: sec(30) },
      { method: TimingMethodType.DELAY, timeMs: min(15), delayMs: sec(30) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },
  {
    id: 18,
    name: '2h+1h+15m+30s Bronstein',
    description: '2h + 1h + 15m + 30s/move Bronstein delay all periods',
    periods: [
      { method: TimingMethodType.DELAY, timeMs: hr(2), delayMs: sec(30) },
      { method: TimingMethodType.DELAY, timeMs: hr(1), delayMs: sec(30) },
      { method: TimingMethodType.DELAY, timeMs: min(15), delayMs: sec(30) },
    ],
    freezeDefault: true,
    soundDefault: false,
  },

  // ===== Byo-yomi Options - Options 19-20 =====
  {
    id: 19,
    name: '1h + Canadian Byo',
    description: '1h TIME, then 5m Canadian byo-yomi (repeating)',
    periods: [
      { method: TimingMethodType.TIME, timeMs: hr(1) },
      { method: TimingMethodType.CANADIAN_BYO, byoTimeMs: min(5) },
    ],
    freezeDefault: false,
    soundDefault: true,
  },
  {
    id: 20,
    name: '1h + 1x20s Byo',
    description: '1h TIME, then 1x20s Japanese byo-yomi (repeating)',
    periods: [
      { method: TimingMethodType.TIME, timeMs: hr(1) },
      { method: TimingMethodType.BYO_YOMI, byoTimeMs: sec(20), byoMoments: 1 },
    ],
    freezeDefault: false,
    soundDefault: true,
  },

  // ===== Scrabble Option - Option 21 =====
  {
    id: 21,
    name: '25m + Upcount',
    description: 'Scrabble: 25 min TIME, then upcount',
    periods: [
      { method: TimingMethodType.TIME, timeMs: min(25) },
      { method: TimingMethodType.UPCOUNT },
    ],
    freezeDefault: false,
    soundDefault: true,
  },

  // ===== US-DELAY Options - Options 22-24 =====
  {
    id: 22,
    name: '5+2s US Delay',
    description: '5 min + 2s/move US delay',
    periods: [
      { method: TimingMethodType.US_DELAY, timeMs: min(5), delayMs: sec(2) },
    ],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 23,
    name: '25+5s US Delay',
    description: '25 min + 5s/move US delay',
    periods: [
      { method: TimingMethodType.US_DELAY, timeMs: min(25), delayMs: sec(5) },
    ],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 24,
    name: '1h55+60m+5s US Delay',
    description: '1h55m + 60m (2nd period) + 5s/move US delay',
    periods: [
      { method: TimingMethodType.US_DELAY, timeMs: hr(1) + min(55), delayMs: sec(5) },
      { method: TimingMethodType.US_DELAY, timeMs: hr(1), delayMs: sec(5) },
    ],
    freezeDefault: false,
    soundDefault: false,
  },

  // ===== Bullet Options - Options 25-26 =====
  {
    id: 25,
    name: '1 min',
    description: 'Bullet 1 minute',
    periods: [{ method: TimingMethodType.TIME, timeMs: min(1) }],
    freezeDefault: false,
    soundDefault: false,
  },
  {
    id: 26,
    name: '30 sec',
    description: 'Ultra Bullet 30 seconds',
    periods: [{ method: TimingMethodType.TIME, timeMs: sec(30) }],
    freezeDefault: false,
    soundDefault: false,
  },
];

/**
 * Get a preset by its option number (1-24).
 * @param {number} id - Option number
 * @returns {object|null}
 */
function getPreset(id) {
  return presets.find((p) => p.id === id) || null;
}

/**
 * Get all presets.
 * @returns {Array<object>}
 */
function getAllPresets() {
  return presets;
}

// --- js/storage/StorageManager.js ---
/**
 * StorageManager - localStorage persistence for custom options and preferences
 *
 * Saves/loads:
 * - Custom options (26-30)
 * - Last selected option number
 * - Theme preference
 * - Sound enabled state
 */


class StorageManager {
  /**
   * Save custom options to localStorage.
   * @param {Array<object|null>} options - Array of 5 custom option configs (index 0 = option 26)
   */
  static saveCustomOptions(options) {
    try {
      localStorage.setItem(StorageKeys.CUSTOM_OPTIONS, JSON.stringify(options));
    } catch (e) {
      console.warn('Failed to save custom options:', e);
    }
  }

  /**
   * Load custom options from localStorage.
   * @returns {Array<object|null>} Array of 5 custom option configs
   */
  static loadCustomOptions() {
    try {
      const data = localStorage.getItem(StorageKeys.CUSTOM_OPTIONS);
      if (data) {
        const parsed = JSON.parse(data);
        // Validate: must be an array
        if (!Array.isArray(parsed)) {
          console.warn('Custom options data is not an array, resetting');
          return [null, null, null, null, null];
        }
        // Normalize to exactly MAX_MANUAL_OPTIONS length
        while (parsed.length < Limits.MAX_MANUAL_OPTIONS) parsed.push(null);
        if (parsed.length > Limits.MAX_MANUAL_OPTIONS) parsed.length = Limits.MAX_MANUAL_OPTIONS;
        // Validate each entry has periods array if not null
        for (let i = 0; i < parsed.length; i++) {
          if (parsed[i] !== null && (!parsed[i].periods || !Array.isArray(parsed[i].periods) || parsed[i].periods.length === 0)) {
            console.warn(`Custom option slot ${i} is invalid, clearing`);
            parsed[i] = null;
          }
        }
        return parsed;
      }
    } catch (e) {
      console.warn('Failed to load custom options:', e);
    }
    return [null, null, null, null, null];
  }

  /**
   * Save a single custom option.
   * @param {number} slot - Slot number (0-4, corresponding to options 26-30)
   * @param {object} config - Option configuration
   */
  static saveCustomOption(slot, config) {
    if (slot < 0 || slot >= Limits.MAX_MANUAL_OPTIONS) return;
    const options = StorageManager.loadCustomOptions();
    options[slot] = config;
    StorageManager.saveCustomOptions(options);
  }

  /**
   * Load a single custom option.
   * @param {number} slot - Slot number (0-4)
   * @returns {object|null}
   */
  static loadCustomOption(slot) {
    if (slot < 0 || slot >= Limits.MAX_MANUAL_OPTIONS) return null;
    const options = StorageManager.loadCustomOptions();
    return options[slot] || null;
  }

  /**
   * Save the last selected option number.
   * @param {number} optionNumber
   */
  static saveLastOption(optionNumber) {
    try {
      localStorage.setItem(StorageKeys.LAST_OPTION, String(optionNumber));
    } catch (e) {
      console.warn('Failed to save last option:', e);
    }
  }

  /**
   * Load the last selected option number.
   * @returns {number} Option number (defaults to 1)
   */
  static loadLastOption() {
    try {
      const val = localStorage.getItem(StorageKeys.LAST_OPTION);
      if (val) {
        const num = parseInt(val, 10);
        if (num >= 1 && num <= Limits.MANUAL_OPTION_END) return num;
      }
    } catch (e) {
      console.warn('Failed to load last option:', e);
    }
    return 1;
  }

  /**
   * Save theme preference.
   * @param {'light'|'dark'|'auto'} theme
   */
  static saveTheme(theme) {
    try {
      localStorage.setItem(StorageKeys.THEME, theme);
    } catch (e) {
      console.warn('Failed to save theme:', e);
    }
  }

  /**
   * Load theme preference.
   * @returns {'light'|'dark'|'auto'}
   */
  static loadTheme() {
    try {
      const val = localStorage.getItem(StorageKeys.THEME);
      if (val === 'light' || val === 'dark' || val === 'auto') return val;
    } catch (e) {
      console.warn('Failed to load theme:', e);
    }
    return 'auto';
  }

  /**
   * Save sound enabled state.
   * @param {boolean} enabled
   */
  static saveSoundEnabled(enabled) {
    try {
      localStorage.setItem(StorageKeys.SOUND_ENABLED, String(enabled));
    } catch (e) {
      console.warn('Failed to save sound state:', e);
    }
  }

  /**
   * Load sound enabled state.
   * @returns {boolean|null} null means use preset default
   */
  static loadSoundEnabled() {
    try {
      const val = localStorage.getItem(StorageKeys.SOUND_ENABLED);
      if (val === 'true') return true;
      if (val === 'false') return false;
    } catch (e) {
      console.warn('Failed to load sound state:', e);
    }
    return null;
  }

  /**
   * Save clock font preference.
   * @param {string} fontId
   */
  static saveFont(fontId) {
    try {
      localStorage.setItem(StorageKeys.FONT, fontId);
    } catch (e) {
      console.warn('Failed to save font:', e);
    }
  }

  /**
   * Load clock font preference.
   * @returns {string}
   */
  static loadFont() {
    try {
      const val = localStorage.getItem(StorageKeys.FONT);
      if (val && Object.values(ClockFont).includes(val)) return val;
    } catch (e) {
      console.warn('Failed to load font:', e);
    }
    return ClockFont.DSEG7_CLASSIC;
  }

  /**
   * Save rotation preference.
   * @param {boolean} rotated
   */
  static saveRotation(rotated) {
    try {
      localStorage.setItem(StorageKeys.ROTATION, String(rotated));
    } catch (e) {
      console.warn('Failed to save rotation:', e);
    }
  }

  /**
   * Load rotation preference.
   * @returns {boolean|null} null means no preference yet
   */
  static loadRotation() {
    try {
      const val = localStorage.getItem(StorageKeys.ROTATION);
      if (val === 'true') return true;
      if (val === 'false') return false;
    } catch (e) {
      console.warn('Failed to load rotation:', e);
    }
    return null;
  }

  /**
   * Create a default custom option config.
   * @returns {object}
   */
  static createDefaultCustomOption() {
    return {
      name: 'Custom',
      description: 'Custom time control',
      periods: [{ method: TimingMethodType.TIME, timeMs: 300000 }], // 5 minutes
      freezeDefault: false,
      soundDefault: false,
    };
  }

  /**
   * Clear all stored data.
   */
  static clearAll() {
    try {
      Object.values(StorageKeys).forEach((key) => {
        localStorage.removeItem(key);
      });
    } catch (e) {
      console.warn('Failed to clear storage:', e);
    }
  }
}

// --- js/ui/SettingsPanel.js ---
/**
 * SettingsPanel - Option selection + manual configuration UI
 *
 * Provides:
 * - Preset option browser (options 1-24)
 * - Custom option editor (options 26-30)
 * - Per-period configuration with method selection
 * - Asymmetric time support
 */


const METHOD_NAMES = {
  [TimingMethodType.TIME]: 'Time (Sudden Death)',
  [TimingMethodType.FISCHER]: 'Fischer Bonus',
  [TimingMethodType.US_DELAY]: 'US Delay',
  [TimingMethodType.DELAY]: 'Bronstein Delay',
  [TimingMethodType.BYO_YOMI]: 'Byo-yomi (Japanese)',
  [TimingMethodType.CANADIAN_BYO]: 'Canadian Byo-yomi',
  [TimingMethodType.UPCOUNT]: 'Upcount (Scrabble)',
  [TimingMethodType.END]: '-- End --',
};

/** Methods that can only be the last period */
const LAST_PERIOD_ONLY = [TimingMethodType.BYO_YOMI, TimingMethodType.CANADIAN_BYO, TimingMethodType.UPCOUNT];

class SettingsPanel {
  /**
   * @param {HTMLElement} containerEl - Settings panel container
   */
  constructor(containerEl) {
    this._container = containerEl;
    this._onSelect = null;
    this._onClose = null;
    this._currentView = 'presets'; // 'presets' | 'custom-list' | 'custom-edit'
    this._editingSlot = -1;
    this._editingConfig = null;
  }

  /**
   * Set callbacks.
   * @param {Function} onSelect - (optionConfig, optionNumber) => void
   * @param {Function} onClose - () => void
   */
  setCallbacks(onSelect, onClose) {
    this._onSelect = onSelect;
    this._onClose = onClose;
  }

  /**
   * Show the settings panel.
   */
  show() {
    this._currentView = 'presets';
    this._render();
    this._container.classList.remove('hidden');
  }

  /**
   * Hide the settings panel.
   */
  hide() {
    this._container.classList.add('hidden');
    if (this._onClose) this._onClose();
  }

  /**
   * Check if visible.
   * @returns {boolean}
   */
  isVisible() {
    return !this._container.classList.contains('hidden');
  }

  /**
   * Render the current view.
   */
  _render() {
    switch (this._currentView) {
      case 'presets':
        this._renderPresets();
        break;
      case 'custom-list':
        this._renderCustomList();
        break;
      case 'custom-edit':
        this._renderCustomEdit();
        break;
    }
  }

  /**
   * Render the preset options grid.
   */
  _renderPresets() {
    this._container.innerHTML = '';
    const panel = document.createElement('div');
    panel.className = 'settings-panel';

    // Header
    const header = document.createElement('div');
    header.className = 'settings-header';
    const title = document.createElement('h2');
    title.textContent = 'Select Time Control';
    const closeBtn = document.createElement('button');
    closeBtn.className = 'btn btn-icon settings-close';
    closeBtn.textContent = '\u2715'; // X
    closeBtn.setAttribute('aria-label', 'Close settings');
    closeBtn.addEventListener('click', () => this.hide());
    header.appendChild(title);
    header.appendChild(closeBtn);
    panel.appendChild(header);

    // Font selector
    const fontGroup = document.createElement('div');
    fontGroup.className = 'settings-font-group';
    const fontLabel = document.createElement('label');
    fontLabel.className = 'form-label';
    fontLabel.textContent = 'Clock Font';
    const fontSelect = document.createElement('select');
    fontSelect.className = 'form-input';
    const currentFont = StorageManager.loadFont();
    for (const font of CLOCK_FONTS) {
      const option = document.createElement('option');
      option.value = font.id;
      option.textContent = font.name;
      option.selected = font.id === currentFont;
      fontSelect.appendChild(option);
    }
    fontSelect.addEventListener('change', (e) => {
      const fontDef = CLOCK_FONTS.find((f) => f.id === e.target.value);
      if (fontDef) {
        StorageManager.saveFont(fontDef.id);
        document.documentElement.style.setProperty('--clock-font', fontDef.family);
      }
    });
    fontGroup.appendChild(fontLabel);
    fontGroup.appendChild(fontSelect);
    panel.appendChild(fontGroup);

    // Tabs
    const tabs = document.createElement('div');
    tabs.className = 'settings-tabs';
    const presetTab = document.createElement('button');
    presetTab.className = 'settings-tab active';
    presetTab.textContent = 'Presets';
    const customTab = document.createElement('button');
    customTab.className = 'settings-tab';
    customTab.textContent = 'Custom';
    customTab.addEventListener('click', () => {
      this._currentView = 'custom-list';
      this._render();
    });
    tabs.appendChild(presetTab);
    tabs.appendChild(customTab);
    panel.appendChild(tabs);

    // Preset grid
    const grid = document.createElement('div');
    grid.className = 'settings-grid';

    for (const preset of presets) {
      const card = document.createElement('button');
      card.className = 'preset-card';
      card.setAttribute('data-option', preset.id);

      const num = document.createElement('span');
      num.className = 'preset-number';
      num.textContent = `#${String(preset.id).padStart(2, '0')}`;

      const name = document.createElement('span');
      name.className = 'preset-name';
      name.textContent = preset.name;

      const desc = document.createElement('span');
      desc.className = 'preset-desc';
      desc.textContent = preset.description;

      const method = document.createElement('span');
      method.className = 'preset-method';
      method.textContent = preset.periods.map((p) => p.method).join(' + ');

      card.appendChild(num);
      card.appendChild(name);
      card.appendChild(desc);
      card.appendChild(method);

      card.addEventListener('click', () => {
        if (this._onSelect) {
          this._onSelect(preset, preset.id);
        }
        this.hide();
      });

      grid.appendChild(card);
    }

    panel.appendChild(grid);
    this._container.appendChild(panel);
  }

  /**
   * Render the custom options list.
   */
  _renderCustomList() {
    this._container.innerHTML = '';
    const panel = document.createElement('div');
    panel.className = 'settings-panel';

    // Header
    const header = document.createElement('div');
    header.className = 'settings-header';
    const title = document.createElement('h2');
    title.textContent = 'Custom Options';
    const closeBtn = document.createElement('button');
    closeBtn.className = 'btn btn-icon settings-close';
    closeBtn.textContent = '\u2715';
    closeBtn.addEventListener('click', () => this.hide());
    header.appendChild(title);
    header.appendChild(closeBtn);
    panel.appendChild(header);

    // Tabs
    const tabs = document.createElement('div');
    tabs.className = 'settings-tabs';
    const presetTab = document.createElement('button');
    presetTab.className = 'settings-tab';
    presetTab.textContent = 'Presets';
    presetTab.addEventListener('click', () => {
      this._currentView = 'presets';
      this._render();
    });
    const customTab = document.createElement('button');
    customTab.className = 'settings-tab active';
    customTab.textContent = 'Custom';
    tabs.appendChild(presetTab);
    tabs.appendChild(customTab);
    panel.appendChild(tabs);

    // Custom slots
    const customOptions = StorageManager.loadCustomOptions();
    const list = document.createElement('div');
    list.className = 'custom-list';

    for (let i = 0; i < Limits.MAX_MANUAL_OPTIONS; i++) {
      const optionNum = Limits.MANUAL_OPTION_START + i;
      const config = customOptions[i];

      const item = document.createElement('div');
      item.className = 'custom-item';

      const info = document.createElement('div');
      info.className = 'custom-info';
      const label = document.createElement('span');
      label.className = 'custom-label';
      label.textContent = `#${optionNum} - Manual Set ${i + 1}`;
      const desc = document.createElement('span');
      desc.className = 'custom-desc';
      desc.textContent = config ? config.name || 'Custom' : 'Empty';
      info.appendChild(label);
      info.appendChild(desc);

      const actions = document.createElement('div');
      actions.className = 'custom-actions';

      if (config) {
        const useBtn = document.createElement('button');
        useBtn.className = 'btn btn-primary btn-sm';
        useBtn.textContent = 'Use';
        useBtn.addEventListener('click', () => {
          if (this._onSelect) {
            this._onSelect(config, optionNum);
          }
          this.hide();
        });
        actions.appendChild(useBtn);
      }

      const editBtn = document.createElement('button');
      editBtn.className = 'btn btn-secondary btn-sm';
      editBtn.textContent = config ? 'Edit' : 'Create';
      editBtn.addEventListener('click', () => {
        this._editingSlot = i;
        this._editingConfig = config ? JSON.parse(JSON.stringify(config)) : StorageManager.createDefaultCustomOption();
        this._currentView = 'custom-edit';
        this._render();
      });
      actions.appendChild(editBtn);

      item.appendChild(info);
      item.appendChild(actions);
      list.appendChild(item);
    }

    panel.appendChild(list);
    this._container.appendChild(panel);
  }

  /**
   * Render the custom option editor.
   */
  _renderCustomEdit() {
    this._container.innerHTML = '';
    const panel = document.createElement('div');
    panel.className = 'settings-panel';

    // Header
    const header = document.createElement('div');
    header.className = 'settings-header';
    const title = document.createElement('h2');
    title.textContent = `Edit Custom #${Limits.MANUAL_OPTION_START + this._editingSlot}`;
    const backBtn = document.createElement('button');
    backBtn.className = 'btn btn-icon';
    backBtn.textContent = '\u2190'; // Left arrow
    backBtn.addEventListener('click', () => {
      this._currentView = 'custom-list';
      this._render();
    });
    header.appendChild(backBtn);
    header.appendChild(title);
    panel.appendChild(header);

    const form = document.createElement('div');
    form.className = 'custom-edit-form';

    // Option name
    const nameGroup = this._createFormGroup('Name', 'text', this._editingConfig.name || 'Custom');
    nameGroup.input.addEventListener('input', (e) => {
      this._editingConfig.name = e.target.value;
    });
    form.appendChild(nameGroup.group);

    // Asymmetric toggle
    const asymmetricGroup = document.createElement('div');
    asymmetricGroup.className = 'form-group';
    const asymLabel = document.createElement('label');
    asymLabel.className = 'form-label';
    const asymCheck = document.createElement('input');
    asymCheck.type = 'checkbox';
    asymCheck.checked = !!this._editingConfig.asymmetric;
    asymLabel.appendChild(asymCheck);
    asymLabel.appendChild(document.createTextNode(' Different times per player'));
    asymmetricGroup.appendChild(asymLabel);
    form.appendChild(asymmetricGroup);

    // Periods
    const periodsSection = document.createElement('div');
    periodsSection.className = 'periods-section';
    const periodsTitle = document.createElement('h3');
    periodsTitle.textContent = 'Periods';
    periodsSection.appendChild(periodsTitle);

    const renderPeriods = () => {
      // Clear existing period forms
      const existingForms = periodsSection.querySelectorAll('.period-form');
      existingForms.forEach((f) => f.remove());

      for (let p = 0; p < this._editingConfig.periods.length; p++) {
        const periodForm = this._createPeriodForm(p, this._editingConfig.periods[p], asymCheck.checked);
        periodsSection.appendChild(periodForm);
      }

      // Add period button (if under max)
      let addBtn = periodsSection.querySelector('.add-period-btn');
      if (addBtn) addBtn.remove();
      if (this._editingConfig.periods.length < Limits.MAX_PERIODS) {
        addBtn = document.createElement('button');
        addBtn.className = 'btn btn-secondary add-period-btn';
        addBtn.textContent = '+ Add Period';
        addBtn.addEventListener('click', () => {
          this._editingConfig.periods.push({ method: TimingMethodType.TIME, timeMs: 300000 });
          renderPeriods();
        });
        periodsSection.appendChild(addBtn);
      }
    };

    renderPeriods();

    asymCheck.addEventListener('change', () => {
      this._editingConfig.asymmetric = asymCheck.checked;
      renderPeriods();
    });

    form.appendChild(periodsSection);

    // Defaults
    const defaultsSection = document.createElement('div');
    defaultsSection.className = 'defaults-section';

    const freezeGroup = document.createElement('div');
    freezeGroup.className = 'form-group';
    const freezeLabel = document.createElement('label');
    freezeLabel.className = 'form-label';
    const freezeCheck = document.createElement('input');
    freezeCheck.type = 'checkbox';
    freezeCheck.checked = !!this._editingConfig.freezeDefault;
    freezeCheck.addEventListener('change', (e) => {
      this._editingConfig.freezeDefault = e.target.checked;
    });
    freezeLabel.appendChild(freezeCheck);
    freezeLabel.appendChild(document.createTextNode(' Freeze on time-out'));
    freezeGroup.appendChild(freezeLabel);
    defaultsSection.appendChild(freezeGroup);

    const soundGroup = document.createElement('div');
    soundGroup.className = 'form-group';
    const soundLabel = document.createElement('label');
    soundLabel.className = 'form-label';
    const soundCheck = document.createElement('input');
    soundCheck.type = 'checkbox';
    soundCheck.checked = !!this._editingConfig.soundDefault;
    soundCheck.addEventListener('change', (e) => {
      this._editingConfig.soundDefault = e.target.checked;
    });
    soundLabel.appendChild(soundCheck);
    soundLabel.appendChild(document.createTextNode(' Sound enabled'));
    soundGroup.appendChild(soundLabel);
    defaultsSection.appendChild(soundGroup);

    form.appendChild(defaultsSection);

    // Save/Cancel buttons
    const buttons = document.createElement('div');
    buttons.className = 'form-buttons';

    const saveBtn = document.createElement('button');
    saveBtn.className = 'btn btn-primary';
    saveBtn.textContent = 'Save & Use';
    saveBtn.addEventListener('click', () => {
      this._promptNameIfDefault(nameGroup.input, () => {
        StorageManager.saveCustomOption(this._editingSlot, this._editingConfig);
        if (this._onSelect) {
          this._onSelect(this._editingConfig, Limits.MANUAL_OPTION_START + this._editingSlot);
        }
        this.hide();
      });
    });

    const saveOnlyBtn = document.createElement('button');
    saveOnlyBtn.className = 'btn btn-secondary';
    saveOnlyBtn.textContent = 'Save';
    saveOnlyBtn.addEventListener('click', () => {
      this._promptNameIfDefault(nameGroup.input, () => {
        StorageManager.saveCustomOption(this._editingSlot, this._editingConfig);
        this._currentView = 'custom-list';
        this._render();
      });
    });

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-secondary';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', () => {
      this._currentView = 'custom-list';
      this._render();
    });

    buttons.appendChild(cancelBtn);
    buttons.appendChild(saveOnlyBtn);
    buttons.appendChild(saveBtn);
    form.appendChild(buttons);

    panel.appendChild(form);
    this._container.appendChild(panel);
  }

  /**
   * Prompt the user to name their custom mode if the name is still the default.
   * Focuses and highlights the name input. Proceeds with callback on confirmation.
   * @param {HTMLInputElement} nameInput - The name input element
   * @param {Function} onConfirm - Callback to run after naming
   */
  _promptNameIfDefault(nameInput, onConfirm) {
    if (this._editingConfig.name === 'Custom' || !this._editingConfig.name.trim()) {
      nameInput.focus();
      nameInput.select();
      nameInput.classList.add('form-input-highlight');
      // Show inline hint
      let hint = nameInput.parentElement.querySelector('.name-hint');
      if (!hint) {
        hint = document.createElement('span');
        hint.className = 'name-hint';
        hint.textContent = 'Give your mode a name, then save again';
        nameInput.parentElement.appendChild(hint);
      }
      // Remove highlight on next input
      const cleanup = () => {
        nameInput.classList.remove('form-input-highlight');
        if (hint) hint.remove();
        nameInput.removeEventListener('input', cleanup);
      };
      nameInput.addEventListener('input', cleanup);
      return;
    }
    onConfirm();
  }

  /**
   * Create a form group with label and input.
   * @param {string} label
   * @param {string} type
   * @param {string|number} value
   * @returns {{ group: HTMLElement, input: HTMLInputElement }}
   */
  _createFormGroup(label, type, value) {
    const group = document.createElement('div');
    group.className = 'form-group';

    const labelEl = document.createElement('label');
    labelEl.className = 'form-label';
    labelEl.textContent = label;

    const input = document.createElement('input');
    input.type = type;
    input.className = 'form-input';
    input.value = value;

    group.appendChild(labelEl);
    group.appendChild(input);

    return { group, input };
  }

  /**
   * Create a time input (hours:minutes:seconds).
   * @param {number} ms - Time in ms
   * @param {Function} onChange - (newMs) => void
   * @param {string} [labelPrefix='']
   * @returns {HTMLElement}
   */
  _createTimeInput(ms, onChange, labelPrefix = '') {
    const container = document.createElement('div');
    container.className = 'time-input-group';

    if (labelPrefix) {
      const label = document.createElement('span');
      label.className = 'time-input-label';
      label.textContent = labelPrefix;
      container.appendChild(label);
    }

    const totalSec = Math.floor(ms / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;

    const hInput = this._createNumberInput(h, 0, 9, 'h');
    const mInput = this._createNumberInput(m, 0, 59, 'm');
    const sInput = this._createNumberInput(s, 0, 59, 's');

    const update = () => {
      const h = parseInt(hInput.value, 10) || 0;
      const m = parseInt(mInput.value, 10) || 0;
      const s = parseInt(sInput.value, 10) || 0;
      const newMs = (h * 3600 + m * 60 + s) * 1000;
      onChange(newMs);
    };

    hInput.addEventListener('input', update);
    mInput.addEventListener('input', update);
    sInput.addEventListener('input', update);

    container.appendChild(hInput);
    const hSuffix = document.createElement('span');
    hSuffix.className = 'time-input-suffix';
    hSuffix.textContent = 'h';
    container.appendChild(hSuffix);

    container.appendChild(mInput);
    const mSuffix = document.createElement('span');
    mSuffix.className = 'time-input-suffix';
    mSuffix.textContent = 'm';
    container.appendChild(mSuffix);

    container.appendChild(sInput);
    const sSuffix = document.createElement('span');
    sSuffix.className = 'time-input-suffix';
    sSuffix.textContent = 's';
    container.appendChild(sSuffix);

    return container;
  }

  /**
   * Create a number input.
   * @param {number} value
   * @param {number} min
   * @param {number} max
   * @param {string} suffix
   * @returns {HTMLInputElement}
   */
  _createNumberInput(value, min, max, suffix) {
    const input = document.createElement('input');
    input.type = 'number';
    input.className = 'form-input form-input-time';
    input.value = value;
    input.min = min;
    input.max = max;
    input.setAttribute('aria-label', suffix);
    return input;
  }

  /**
   * Create a period configuration form.
   * @param {number} periodIndex
   * @param {object} periodConfig
   * @param {boolean} asymmetric
   * @returns {HTMLElement}
   */
  _createPeriodForm(periodIndex, periodConfig, asymmetric) {
    const container = document.createElement('div');
    container.className = 'period-form';

    const periodHeader = document.createElement('div');
    periodHeader.className = 'period-header';
    const periodTitle = document.createElement('span');
    periodTitle.textContent = `Period ${periodIndex + 1}`;
    periodHeader.appendChild(periodTitle);

    // Remove button
    if (periodIndex > 0) {
      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn btn-icon btn-sm';
      removeBtn.textContent = '\u2715';
      removeBtn.title = 'Remove period';
      removeBtn.addEventListener('click', () => {
        this._editingConfig.periods.splice(periodIndex, 1);
        this._currentView = 'custom-edit';
        this._render();
      });
      periodHeader.appendChild(removeBtn);
    }
    container.appendChild(periodHeader);

    // Method selector
    const methodGroup = document.createElement('div');
    methodGroup.className = 'form-group';
    const methodLabel = document.createElement('label');
    methodLabel.className = 'form-label';
    methodLabel.textContent = 'Method';
    const methodSelect = document.createElement('select');
    methodSelect.className = 'form-input';

    const isLastPeriod = periodIndex === this._editingConfig.periods.length - 1;

    for (const [key, name] of Object.entries(METHOD_NAMES)) {
      if (key === TimingMethodType.END) continue; // END is not user-selectable
      // Last-period-only methods can only appear as last period
      if (LAST_PERIOD_ONLY.includes(key) && !isLastPeriod) continue;

      const option = document.createElement('option');
      option.value = key;
      option.textContent = name;
      option.selected = key === periodConfig.method;
      methodSelect.appendChild(option);
    }

    methodSelect.addEventListener('change', (e) => {
      this._editingConfig.periods[periodIndex].method = e.target.value;
      // Reset method-specific fields
      this._currentView = 'custom-edit';
      this._render();
    });

    methodGroup.appendChild(methodLabel);
    methodGroup.appendChild(methodSelect);
    container.appendChild(methodGroup);

    // Method-specific fields
    const method = periodConfig.method;

    // Main time (for all except Upcount)
    if (method !== TimingMethodType.UPCOUNT && method !== TimingMethodType.BYO_YOMI && method !== TimingMethodType.CANADIAN_BYO) {
      const timeInput = this._createTimeInput(
        periodConfig.timeMs || 0,
        (newMs) => { this._editingConfig.periods[periodIndex].timeMs = newMs; },
        'Main time',
      );
      container.appendChild(timeInput);

      // Asymmetric: right player time
      if (asymmetric && periodIndex === 0) {
        const rightTimeInput = this._createTimeInput(
          this._editingConfig.rightTimeMs || periodConfig.timeMs || 0,
          (newMs) => { this._editingConfig.rightTimeMs = newMs; },
          'Right player time',
        );
        container.appendChild(rightTimeInput);
      }
    }

    // Bonus/Delay time (for Fischer, Delay, US-Delay)
    if (method === TimingMethodType.FISCHER || method === TimingMethodType.DELAY || method === TimingMethodType.US_DELAY) {
      const delayLabel = method === TimingMethodType.FISCHER ? 'Bonus/move' : 'Delay/move';
      const delayContainer = document.createElement('div');
      delayContainer.className = 'form-group';
      const dlabel = document.createElement('label');
      dlabel.className = 'form-label';
      dlabel.textContent = delayLabel;

      const delayInput = this._createNumberInput(
        Math.floor((periodConfig.delayMs || 0) / 1000), 0, 300, 'seconds',
      );
      delayInput.addEventListener('input', (e) => {
        this._editingConfig.periods[periodIndex].delayMs = (parseInt(e.target.value, 10) || 0) * 1000;
      });

      const secLabel = document.createElement('span');
      secLabel.textContent = ' sec';

      delayContainer.appendChild(dlabel);
      delayContainer.appendChild(delayInput);
      delayContainer.appendChild(secLabel);
      container.appendChild(delayContainer);
    }

    // Moves required (for Fischer)
    if (method === TimingMethodType.FISCHER) {
      const movesContainer = document.createElement('div');
      movesContainer.className = 'form-group';
      const mlabel = document.createElement('label');
      mlabel.className = 'form-label';
      mlabel.textContent = 'Moves (0 = until time expires)';

      const movesInput = this._createNumberInput(
        periodConfig.movesRequired || 0, 0, 999, 'moves',
      );
      movesInput.addEventListener('input', (e) => {
        this._editingConfig.periods[periodIndex].movesRequired = parseInt(e.target.value, 10) || 0;
      });

      movesContainer.appendChild(mlabel);
      movesContainer.appendChild(movesInput);
      container.appendChild(movesContainer);
    }

    // Byo-yomi time and moments
    if (method === TimingMethodType.BYO_YOMI) {
      const byoTimeInput = this._createTimeInput(
        periodConfig.byoTimeMs || 0,
        (newMs) => { this._editingConfig.periods[periodIndex].byoTimeMs = newMs; },
        'Time per moment',
      );
      container.appendChild(byoTimeInput);

      const momentsContainer = document.createElement('div');
      momentsContainer.className = 'form-group';
      const momLabel = document.createElement('label');
      momLabel.className = 'form-label';
      momLabel.textContent = 'Moments (0 = infinite)';

      const momInput = this._createNumberInput(
        periodConfig.byoMoments || 0, 0, Limits.MAX_BYO_MOMENTS, 'moments',
      );
      momInput.addEventListener('input', (e) => {
        this._editingConfig.periods[periodIndex].byoMoments = parseInt(e.target.value, 10) || 0;
      });

      momentsContainer.appendChild(momLabel);
      momentsContainer.appendChild(momInput);
      container.appendChild(momentsContainer);
    }

    // Canadian Byo-yomi time
    if (method === TimingMethodType.CANADIAN_BYO) {
      const cbyoTimeInput = this._createTimeInput(
        periodConfig.byoTimeMs || 0,
        (newMs) => {
          this._editingConfig.periods[periodIndex].byoTimeMs = Math.min(newMs, Limits.MAX_CANADIAN_TIME_MS);
        },
        'Time for move group (max 9:59)',
      );
      container.appendChild(cbyoTimeInput);
    }

    return container;
  }
}

// --- js/ui/CorrectionMode.js ---
/**
 * CorrectionMode - Time correction / arbiter mode UI
 *
 * Allows editing:
 * - Time for both players (all digits)
 * - Move counts
 * - Period numbers
 * - Color swap (by changing right side moves independently)
 *
 * Navigation with arrow keys/buttons, adjustment with +/-.
 */


/**
 * Editable fields in correction mode.
 * Order: leftHours, leftMin, leftSec, rightHours, rightMin, rightSec,
 *        leftMoves, rightMoves, leftPeriod, rightPeriod
 */
const FIELDS = [
  { side: 'left', type: 'hours', label: 'Left Hours' },
  { side: 'left', type: 'minutes', label: 'Left Minutes' },
  { side: 'left', type: 'seconds', label: 'Left Seconds' },
  { side: 'right', type: 'hours', label: 'Right Hours' },
  { side: 'right', type: 'minutes', label: 'Right Minutes' },
  { side: 'right', type: 'seconds', label: 'Right Seconds' },
  { side: 'left', type: 'moves', label: 'Left Moves' },
  { side: 'right', type: 'moves', label: 'Right Moves' },
  { side: 'left', type: 'period', label: 'Left Period' },
  { side: 'right', type: 'period', label: 'Right Period' },
];

class CorrectionMode {
  /**
   * @param {HTMLElement} overlayEl - Overlay container for correction mode
   */
  constructor(overlayEl) {
    this._overlay = overlayEl;
    this._activeFieldIndex = 0;
    this._values = {};
    this._fieldElements = [];
    this._onSave = null;
    this._onCancel = null;
    this._active = false;
  }

  /**
   * Enter correction mode with current game state values.
   * @param {object} state
   * @param {number} state.leftTimeMs
   * @param {number} state.rightTimeMs
   * @param {number} state.leftMoves
   * @param {number} state.rightMoves
   * @param {number} state.leftPeriod
   * @param {number} state.rightPeriod
   * @param {number} state.totalPeriods
   * @param {Function} onSave - (correctedValues) => void
   * @param {Function} onCancel - () => void
   */
  enter(state, onSave, onCancel) {
    this._onSave = onSave;
    this._onCancel = onCancel;
    this._active = true;

    // Parse current times into hours/min/sec
    const leftTime = this._msToComponents(state.leftTimeMs);
    const rightTime = this._msToComponents(state.rightTimeMs);

    this._values = {
      leftHours: leftTime.hours,
      leftMinutes: leftTime.minutes,
      leftSeconds: leftTime.seconds,
      rightHours: rightTime.hours,
      rightMinutes: rightTime.minutes,
      rightSeconds: rightTime.seconds,
      leftMoves: state.leftMoves,
      rightMoves: state.rightMoves,
      leftPeriod: state.leftPeriod,
      rightPeriod: state.rightPeriod,
      totalPeriods: state.totalPeriods,
    };

    this._activeFieldIndex = 0;
    this._render();
    this._overlay.classList.remove('hidden');
  }

  /**
   * Exit correction mode.
   */
  exit() {
    this._active = false;
    this._overlay.classList.add('hidden');
    this._overlay.innerHTML = '';
    this._fieldElements = [];
  }

  /**
   * @returns {boolean}
   */
  isActive() {
    return this._active;
  }

  /**
   * Navigate to the next field.
   */
  nextField() {
    if (!this._active) return;
    this._activeFieldIndex = (this._activeFieldIndex + 1) % FIELDS.length;
    this._updateHighlight();
  }

  /**
   * Navigate to the previous field.
   */
  prevField() {
    if (!this._active) return;
    this._activeFieldIndex = (this._activeFieldIndex - 1 + FIELDS.length) % FIELDS.length;
    this._updateHighlight();
  }

  /**
   * Increment the active field.
   */
  increment() {
    if (!this._active) return;
    this._adjustField(1);
  }

  /**
   * Decrement the active field.
   */
  decrement() {
    if (!this._active) return;
    this._adjustField(-1);
  }

  /**
   * Save and exit correction mode.
   */
  save() {
    if (!this._active) return;

    const leftTimeMs = this._componentsToMs(
      this._values.leftHours,
      this._values.leftMinutes,
      this._values.leftSeconds,
    );
    const rightTimeMs = this._componentsToMs(
      this._values.rightHours,
      this._values.rightMinutes,
      this._values.rightSeconds,
    );

    if (this._onSave) {
      this._onSave({
        leftTimeMs,
        rightTimeMs,
        leftMoves: this._values.leftMoves,
        rightMoves: this._values.rightMoves,
        leftPeriod: this._values.leftPeriod,
        rightPeriod: this._values.rightPeriod,
      });
    }

    this.exit();
  }

  /**
   * Cancel and exit correction mode.
   */
  cancel() {
    if (this._onCancel) {
      this._onCancel();
    }
    this.exit();
  }

  /**
   * Adjust the current field value.
   * @param {number} delta
   */
  _adjustField(delta) {
    const field = FIELDS[this._activeFieldIndex];
    const key = `${field.side}${field.type.charAt(0).toUpperCase()}${field.type.slice(1)}`;

    switch (field.type) {
      case 'hours':
        this._values[key] = Math.max(0, Math.min(9, this._values[key] + delta));
        break;
      case 'minutes':
        this._values[key] = Math.max(0, Math.min(59, this._values[key] + delta));
        break;
      case 'seconds':
        this._values[key] = Math.max(0, Math.min(59, this._values[key] + delta));
        break;
      case 'moves': {
        const newVal = Math.max(0, this._values[key] + delta);
        const oldVal = this._values[key];
        this._values[key] = newVal;

        // Linked behavior: changing left moves auto-updates right
        if (field.side === 'left') {
          const diff = newVal - oldVal;
          this._values.rightMoves = Math.max(0, this._values.rightMoves + diff);
        }
        break;
      }
      case 'period':
        this._values[key] = Math.max(0, Math.min(this._values.totalPeriods - 1, this._values[key] + delta));
        break;
    }

    this._updateDisplay();
  }

  /**
   * Render the correction mode overlay.
   */
  _render() {
    this._overlay.innerHTML = '';

    const container = document.createElement('div');
    container.className = 'correction-container';

    // Title
    const title = document.createElement('h3');
    title.className = 'correction-title';
    title.textContent = 'Time Correction';
    container.appendChild(title);

    // Time editing grid
    const grid = document.createElement('div');
    grid.className = 'correction-grid';

    // Left time
    const leftLabel = document.createElement('div');
    leftLabel.className = 'correction-label';
    leftLabel.textContent = 'Left';
    grid.appendChild(leftLabel);

    const leftTimeRow = document.createElement('div');
    leftTimeRow.className = 'correction-time-row';
    this._fieldElements = [];

    // Build field displays (tappable to select)
    for (let i = 0; i < FIELDS.length; i++) {
      const field = FIELDS[i];
      const key = `${field.side}${field.type.charAt(0).toUpperCase()}${field.type.slice(1)}`;

      const el = document.createElement('span');
      el.className = 'correction-field';
      el.setAttribute('data-field-index', i);
      el.setAttribute('title', field.label);
      el.textContent = String(this._values[key]).padStart(field.type === 'moves' ? 3 : 2, '0');

      // Tap to select this field
      const fieldIndex = i;
      el.addEventListener('click', (e) => {
        e.preventDefault();
        this._activeFieldIndex = fieldIndex;
        this._updateHighlight();
      });

      this._fieldElements.push(el);
    }

    // Arrange: Left time
    const leftTimeDisplay = document.createElement('div');
    leftTimeDisplay.className = 'correction-time';
    leftTimeDisplay.appendChild(this._fieldElements[0]);
    leftTimeDisplay.appendChild(document.createTextNode(':'));
    leftTimeDisplay.appendChild(this._fieldElements[1]);
    leftTimeDisplay.appendChild(document.createTextNode(':'));
    leftTimeDisplay.appendChild(this._fieldElements[2]);
    grid.appendChild(leftTimeDisplay);

    // Right time
    const rightLabel = document.createElement('div');
    rightLabel.className = 'correction-label';
    rightLabel.textContent = 'Right';
    grid.appendChild(rightLabel);

    const rightTimeDisplay = document.createElement('div');
    rightTimeDisplay.className = 'correction-time';
    rightTimeDisplay.appendChild(this._fieldElements[3]);
    rightTimeDisplay.appendChild(document.createTextNode(':'));
    rightTimeDisplay.appendChild(this._fieldElements[4]);
    rightTimeDisplay.appendChild(document.createTextNode(':'));
    rightTimeDisplay.appendChild(this._fieldElements[5]);
    grid.appendChild(rightTimeDisplay);

    // Moves
    const movesLabel = document.createElement('div');
    movesLabel.className = 'correction-label';
    movesLabel.textContent = 'Moves';
    grid.appendChild(movesLabel);

    const movesRow = document.createElement('div');
    movesRow.className = 'correction-moves-row';
    movesRow.appendChild(this._fieldElements[6]);
    movesRow.appendChild(document.createTextNode(' / '));
    movesRow.appendChild(this._fieldElements[7]);
    grid.appendChild(movesRow);

    // Periods (only show if multiple periods)
    if (this._values.totalPeriods > 1) {
      const periodLabel = document.createElement('div');
      periodLabel.className = 'correction-label';
      periodLabel.textContent = 'Period';
      grid.appendChild(periodLabel);

      const periodRow = document.createElement('div');
      periodRow.className = 'correction-period-row';
      periodRow.appendChild(this._fieldElements[8]);
      periodRow.appendChild(document.createTextNode(' / '));
      periodRow.appendChild(this._fieldElements[9]);
      grid.appendChild(periodRow);
    }

    container.appendChild(grid);

    // Touch navigation and adjustment controls
    const controls = document.createElement('div');
    controls.className = 'correction-controls';

    const prevBtn = document.createElement('button');
    prevBtn.className = 'btn btn-control';
    prevBtn.textContent = '\u25C0';
    prevBtn.title = 'Previous field';
    prevBtn.addEventListener('click', (e) => { e.preventDefault(); this.prevField(); });

    const decBtn = document.createElement('button');
    decBtn.className = 'btn btn-control btn-control-adj';
    decBtn.textContent = '\u2212';
    decBtn.title = 'Decrease';
    decBtn.addEventListener('click', (e) => { e.preventDefault(); this.decrement(); });

    const incBtn = document.createElement('button');
    incBtn.className = 'btn btn-control btn-control-adj';
    incBtn.textContent = '+';
    incBtn.title = 'Increase';
    incBtn.addEventListener('click', (e) => { e.preventDefault(); this.increment(); });

    const nextBtn = document.createElement('button');
    nextBtn.className = 'btn btn-control';
    nextBtn.textContent = '\u25B6';
    nextBtn.title = 'Next field';
    nextBtn.addEventListener('click', (e) => { e.preventDefault(); this.nextField(); });

    controls.appendChild(prevBtn);
    controls.appendChild(decBtn);
    controls.appendChild(incBtn);
    controls.appendChild(nextBtn);
    container.appendChild(controls);

    // Buttons
    const buttons = document.createElement('div');
    buttons.className = 'correction-buttons';

    const saveBtn = document.createElement('button');
    saveBtn.className = 'btn btn-primary';
    saveBtn.textContent = 'Save';
    saveBtn.addEventListener('click', () => this.save());

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-secondary';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', () => this.cancel());

    buttons.appendChild(cancelBtn);
    buttons.appendChild(saveBtn);
    container.appendChild(buttons);

    // Instructions
    const help = document.createElement('div');
    help.className = 'correction-help';
    help.textContent = 'Tap a field to select it. Use \u25C0\u25B6 or \u2190\u2192 to navigate, \u2212/+ or \u2191\u2193 to adjust.';
    container.appendChild(help);

    this._overlay.appendChild(container);
    this._updateHighlight();
  }

  /**
   * Update the field highlight.
   */
  _updateHighlight() {
    for (let i = 0; i < this._fieldElements.length; i++) {
      this._fieldElements[i].classList.toggle('correction-active', i === this._activeFieldIndex);
    }
  }

  /**
   * Update all field display values.
   */
  _updateDisplay() {
    for (let i = 0; i < FIELDS.length; i++) {
      const field = FIELDS[i];
      const key = `${field.side}${field.type.charAt(0).toUpperCase()}${field.type.slice(1)}`;
      const padLen = field.type === 'moves' ? 3 : 2;
      this._fieldElements[i].textContent = String(this._values[key]).padStart(padLen, '0');
    }
  }

  /**
   * Convert ms to hours/minutes/seconds components.
   * @param {number} ms
   * @returns {{ hours: number, minutes: number, seconds: number }}
   */
  _msToComponents(ms) {
    const totalSeconds = Math.floor(Math.max(0, ms) / 1000);
    return {
      hours: Math.floor(totalSeconds / 3600),
      minutes: Math.floor((totalSeconds % 3600) / 60),
      seconds: totalSeconds % 60,
    };
  }

  /**
   * Convert components to ms.
   * @param {number} hours
   * @param {number} minutes
   * @param {number} seconds
   * @returns {number}
   */
  _componentsToMs(hours, minutes, seconds) {
    return (hours * 3600 + minutes * 60 + seconds) * 1000;
  }
}

// --- js/ui/SoundManager.js ---
/**
 * SoundManager - Web Audio API beep generation
 *
 * Generates tones programmatically for:
 * - Warning beep at 10 seconds remaining
 * - Short beep every second in last 5 seconds
 * - Longer beep at 0:00
 * - Byo-yomi moment end beep
 */


class SoundManager {
  constructor() {
    /** @type {AudioContext|null} */
    this._ctx = null;
    /** @type {boolean} */
    this._enabled = false;
    /** @type {number|null} Last second we beeped for (to avoid double-beeping) */
    this._lastBeepSecond = null;
    /** @type {boolean} Whether the warning beep (at 10s) has been played */
    this._warningPlayed = false;
  }

  /**
   * Initialize the AudioContext (must be called from a user gesture).
   */
  init() {
    if (!this._ctx) {
      this._ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (this._ctx.state === 'suspended') {
      this._ctx.resume();
    }
  }

  /**
   * Enable or disable sound.
   * @param {boolean} enabled
   */
  setEnabled(enabled) {
    this._enabled = enabled;
    if (enabled) {
      this.init();
    }
  }

  /**
   * Toggle sound on/off.
   * @returns {boolean} New enabled state
   */
  toggle() {
    this._enabled = !this._enabled;
    if (this._enabled) {
      this.init();
    }
    return this._enabled;
  }

  /**
   * @returns {boolean}
   */
  isEnabled() {
    return this._enabled;
  }

  /**
   * Check remaining time and play appropriate beeps.
   * Should be called every tick for the active player.
   * @param {number} remainingMs - Remaining time in milliseconds
   */
  checkAndBeep(remainingMs) {
    if (!this._enabled) return;

    const remainingSeconds = Math.ceil(remainingMs / 1000);

    // Warning beep at 10 seconds
    if (remainingMs <= SoundConfig.WARNING_TIME_MS && !this._warningPlayed && remainingMs > SoundConfig.COUNTDOWN_START_MS) {
      this._warningPlayed = true;
      this._playBeep(SoundConfig.BEEP_FREQUENCY, SoundConfig.BEEP_DURATION_SHORT);
      this._lastBeepSecond = remainingSeconds;
      return;
    }

    // Beep every second in last 5 seconds
    if (remainingMs <= SoundConfig.COUNTDOWN_START_MS && remainingMs > SoundConfig.FINAL_BEEP_MS) {
      if (this._lastBeepSecond !== remainingSeconds) {
        this._lastBeepSecond = remainingSeconds;
        this._playBeep(SoundConfig.BEEP_FREQUENCY, SoundConfig.BEEP_DURATION_SHORT);
      }
      return;
    }

    // Longer beep in the last second
    if (remainingMs <= SoundConfig.FINAL_BEEP_MS && remainingMs > 0) {
      if (this._lastBeepSecond !== 0) {
        this._lastBeepSecond = 0;
        this._playBeep(SoundConfig.BEEP_FREQUENCY, SoundConfig.BEEP_DURATION_LONG);
      }
    }
  }

  /**
   * Play a beep for byo-yomi moment expiry.
   */
  playMomentBeep() {
    if (!this._enabled) return;
    this._playBeep(SoundConfig.BEEP_FREQUENCY * 1.5, SoundConfig.BEEP_DURATION_LONG);
  }

  /**
   * Play a beep for period transition.
   */
  playPeriodBeep() {
    if (!this._enabled) return;
    this._playBeep(SoundConfig.BEEP_FREQUENCY, SoundConfig.BEEP_DURATION_LONG);
  }

  /**
   * Reset beep tracking state (call on turn switch or game start).
   */
  resetBeepState() {
    this._lastBeepSecond = null;
    this._warningPlayed = false;
  }

  /**
   * Play a beep tone.
   * @param {number} frequency - Frequency in Hz
   * @param {number} duration - Duration in ms
   */
  _playBeep(frequency, duration) {
    if (!this._ctx) {
      this.init();
    }
    if (!this._ctx) return;

    try {
      const oscillator = this._ctx.createOscillator();
      const gainNode = this._ctx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(this._ctx.destination);

      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(frequency, this._ctx.currentTime);

      gainNode.gain.setValueAtTime(SoundConfig.BEEP_VOLUME, this._ctx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this._ctx.currentTime + duration / 1000);

      oscillator.onended = () => {
        oscillator.disconnect();
        gainNode.disconnect();
      };

      oscillator.start(this._ctx.currentTime);
      oscillator.stop(this._ctx.currentTime + duration / 1000);
    } catch (e) {
      // Silently fail if audio context is not available
    }
  }

  /**
   * Clean up resources.
   */
  destroy() {
    if (this._ctx) {
      this._ctx.close();
      this._ctx = null;
    }
  }
}

// --- js/ui/ThemeManager.js ---
/**
 * ThemeManager - Dark/light theme switching
 *
 * Supports:
 * - Auto detection via prefers-color-scheme
 * - Manual toggle
 * - Persistence in localStorage
 */


class ThemeManager {
  constructor() {
    /** @type {'light'|'dark'|'auto'} */
    this._preference = StorageManager.loadTheme();
    /** @type {MediaQueryList|null} */
    this._mediaQuery = null;
    /** @type {Function|null} */
    this._mediaListener = null;
  }

  /**
   * Initialize the theme manager and apply the current theme.
   */
  init() {
    // Listen for system preference changes
    if (window.matchMedia) {
      this._mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      this._mediaListener = () => this._applyTheme();
      this._mediaQuery.addEventListener('change', this._mediaListener);
    }

    this._applyTheme();
  }

  /**
   * Get the current effective theme.
   * @returns {'light'|'dark'}
   */
  getEffectiveTheme() {
    if (this._preference === 'auto') {
      return this._mediaQuery && this._mediaQuery.matches ? 'dark' : 'light';
    }
    return this._preference;
  }

  /**
   * Get the current preference setting.
   * @returns {'light'|'dark'|'auto'}
   */
  getPreference() {
    return this._preference;
  }

  /**
   * Set theme preference.
   * @param {'light'|'dark'|'auto'} pref
   */
  setPreference(pref) {
    this._preference = pref;
    StorageManager.saveTheme(pref);
    this._applyTheme();
  }

  /**
   * Cycle through theme options: auto -> light -> dark -> auto
   */
  cycle() {
    const order = ['auto', 'light', 'dark'];
    const idx = order.indexOf(this._preference);
    const next = order[(idx + 1) % order.length];
    this.setPreference(next);
    return next;
  }

  /**
   * Apply the current theme to the document.
   */
  _applyTheme() {
    const theme = this.getEffectiveTheme();
    document.documentElement.setAttribute('data-theme', theme);
  }

  /**
   * Clean up listeners.
   */
  destroy() {
    if (this._mediaQuery && this._mediaListener) {
      this._mediaQuery.removeEventListener('change', this._mediaListener);
    }
  }
}

// --- js/ui/RotationManager.js ---
/**
 * RotationManager - 90° rotation for mobile flat-on-table use
 *
 * Auto-detects mobile portrait and rotates the clock UI so both
 * players can read their side when the phone is laid flat.
 * User preference is persisted and always wins over auto-detection.
 */


class RotationManager {
  constructor() {
    /** @type {boolean} */
    this._rotated = false;
    /** @type {HTMLElement|null} */
    this._appEl = null;
  }

  /**
   * Initialize rotation state and apply to the app element.
   * @param {HTMLElement} appEl - The #app element
   */
  init(appEl) {
    this._appEl = appEl;

    const saved = StorageManager.loadRotation();
    if (saved !== null) {
      this._rotated = saved;
    } else {
      // Auto-detect: rotate on mobile portrait with touch
      this._rotated = this._isMobilePortrait();
    }

    this._apply();
  }

  /**
   * Toggle rotation state.
   * @returns {boolean} New rotated state
   */
  toggle() {
    this._rotated = !this._rotated;
    StorageManager.saveRotation(this._rotated);
    this._apply();
    return this._rotated;
  }

  /**
   * @returns {boolean}
   */
  isRotated() {
    return this._rotated;
  }

  /**
   * Detect mobile portrait: narrow viewport in portrait orientation with touch.
   * @returns {boolean}
   */
  _isMobilePortrait() {
    const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const portrait = window.matchMedia('(orientation: portrait)').matches;
    const narrow = window.matchMedia('(max-width: 600px)').matches;
    return hasTouch && portrait && narrow;
  }

  /**
   * Apply or remove the .rotated class on the app element.
   */
  _apply() {
    if (this._appEl) {
      this._appEl.classList.toggle('rotated', this._rotated);
    }
  }
}

// --- js/input/InputHandler.js ---
/**
 * InputHandler - Touch, click, and keyboard event handling
 *
 * Handles:
 * - Tap/click on clock faces to switch turns
 * - Keyboard shortcuts
 * - Long press detection (for sound toggle, freeze toggle, etc.)
 * - Touch events with proper handling to prevent double-fires
 */


class InputHandler {
  constructor() {
    /** @type {Map<string, Function>} Event handlers */
    this._handlers = new Map();
    /** @type {Map<string, number>} Long press timers */
    this._longPressTimers = new Map();
    /** @type {Set<string>} Currently held keys */
    this._heldKeys = new Set();
    /** @type {number} Timestamp of the last touch event (for ghost click prevention) */
    this._lastTouchTime = 0;
    /** @type {Array<Function>} Cleanup functions */
    this._cleanups = [];
  }

  /**
   * Register an event handler.
   * @param {string} event - Event name
   * @param {Function} handler
   */
  on(event, handler) {
    this._handlers.set(event, handler);
  }

  /**
   * Emit an event.
   * @param {string} event
   * @param {*} data
   */
  emit(event, data) {
    const handler = this._handlers.get(event);
    if (handler) handler(data);
  }

  /**
   * Bind click/touch events to clock face elements.
   * @param {HTMLElement} leftEl - Left clock face
   * @param {HTMLElement} rightEl - Right clock face
   */
  bindClockFaces(leftEl, rightEl) {
    this._bindClockFace(leftEl, 'left');
    this._bindClockFace(rightEl, 'right');
  }

  /**
   * Bind events to a single clock face.
   * @param {HTMLElement} el
   * @param {string} side
   */
  _bindClockFace(el, side) {
    // Touch events
    const touchStart = (e) => {
      e.preventDefault();
      this._lastTouchTime = Date.now();
      this.emit('clockTap', side);
    };

    // Click events (for mouse/desktop)
    const click = (e) => {
      // Ignore ghost click after touch (within 500ms)
      if (this._lastTouchTime && Date.now() - this._lastTouchTime < 500) {
        return;
      }
      this.emit('clockTap', side);
    };

    // Keyboard support for role="button" elements (Enter/Space activation)
    const keyDown = (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.emit('clockTap', side);
      }
    };

    el.addEventListener('touchstart', touchStart, { passive: false });
    el.addEventListener('click', click);
    el.addEventListener('keydown', keyDown);

    this._cleanups.push(() => {
      el.removeEventListener('touchstart', touchStart);
      el.removeEventListener('click', click);
      el.removeEventListener('keydown', keyDown);
    });
  }

  /**
   * Bind keyboard events to the document.
   */
  bindKeyboard() {
    const keyDown = (e) => {
      const key = e.key;

      // Prevent default for our shortcuts (avoid page scrolling on space, etc.)
      if (Keys.SWITCH_TURN.includes(key) ||
          Keys.PAUSE.includes(key) ||
          Keys.SOUND_TOGGLE.includes(key) ||
          Keys.FREEZE_TOGGLE.includes(key) ||
          Keys.MOVE_COUNT.includes(key) ||
          Keys.RESET.includes(key) ||
          Keys.ESCAPE.includes(key) ||
          Keys.NAV_LEFT.includes(key) ||
          Keys.NAV_RIGHT.includes(key) ||
          Keys.NAV_UP.includes(key) ||
          Keys.NAV_DOWN.includes(key)) {
        e.preventDefault();
      }

      // Prevent key repeat
      if (this._heldKeys.has(key)) return;
      this._heldKeys.add(key);

      if (Keys.SWITCH_TURN.includes(key)) {
        this.emit('switchTurn');
      } else if (Keys.PAUSE.includes(key)) {
        this.emit('togglePause');
      } else if (Keys.SOUND_TOGGLE.includes(key)) {
        this.emit('toggleSound');
      } else if (Keys.FREEZE_TOGGLE.includes(key)) {
        this.emit('toggleFreeze');
      } else if (Keys.MOVE_COUNT.includes(key)) {
        this.emit('showMoves', true);
      } else if (Keys.RESET.includes(key)) {
        this.emit('reset');
      } else if (Keys.ESCAPE.includes(key)) {
        this.emit('escape');
      } else if (Keys.NAV_LEFT.includes(key)) {
        this.emit('navLeft');
      } else if (Keys.NAV_RIGHT.includes(key)) {
        this.emit('navRight');
      } else if (Keys.NAV_UP.includes(key)) {
        this.emit('navUp');
      } else if (Keys.NAV_DOWN.includes(key)) {
        this.emit('navDown');
      } else if (key >= '1' && key <= '9') {
        // Number keys for quick preset selection
        this.emit('quickPreset', parseInt(key, 10));
      } else if (key === '0') {
        this.emit('quickPreset', 10);
      }
    };

    const keyUp = (e) => {
      this._heldKeys.delete(e.key);

      if (Keys.MOVE_COUNT.includes(e.key)) {
        this.emit('showMoves', false);
      }
    };

    document.addEventListener('keydown', keyDown);
    document.addEventListener('keyup', keyUp);

    this._cleanups.push(() => {
      document.removeEventListener('keydown', keyDown);
      document.removeEventListener('keyup', keyUp);
    });
  }

  /**
   * Bind a button element with optional long press.
   * @param {HTMLElement} el
   * @param {string} tapEvent - Event to emit on tap
   * @param {string} [longPressEvent] - Event to emit on long press
   */
  bindButton(el, tapEvent, longPressEvent) {
    let longPressTimer = null;
    let longPressed = false;
    let lastTouchTime = 0;

    const start = (isTouch) => (e) => {
      e.preventDefault();
      // Prevent mouse events firing after touch events (ghost click guard)
      if (!isTouch && Date.now() - lastTouchTime < 500) return;
      if (isTouch) lastTouchTime = Date.now();

      longPressed = false;

      if (longPressEvent) {
        longPressTimer = setTimeout(() => {
          longPressed = true;
          this.emit(longPressEvent);
        }, UIConfig.LONG_PRESS_MS);
      }
    };

    const end = (isTouch) => (e) => {
      // Prevent mouse events firing after touch events
      if (!isTouch && Date.now() - lastTouchTime < 500) return;

      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      if (!longPressed) {
        this.emit(tapEvent);
      }
    };

    const cancel = () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };

    el.addEventListener('touchstart', start(true), { passive: false });
    el.addEventListener('touchend', end(true));
    el.addEventListener('touchcancel', cancel);
    el.addEventListener('mousedown', start(false));
    el.addEventListener('mouseup', end(false));
    el.addEventListener('mouseleave', cancel);

    this._cleanups.push(() => {
      el.removeEventListener('touchstart', start);
      el.removeEventListener('touchend', end);
      el.removeEventListener('touchcancel', cancel);
      el.removeEventListener('mousedown', start);
      el.removeEventListener('mouseup', end);
      el.removeEventListener('mouseleave', cancel);
    });
  }

  /**
   * Clean up all event listeners.
   */
  destroy() {
    for (const cleanup of this._cleanups) {
      cleanup();
    }
    this._cleanups = [];
    this._handlers.clear();
    this._heldKeys.clear();
  }
}

// --- js/vendor/NoSleep.js ---
/**
 * NoSleep.js v0.12.0
 * https://github.com/richtr/NoSleep.js
 * Rich Tibbett - MIT license
 *
 * Vendored as ES module for TempoMate's build system.
 * Only the video-based fallback is used here; the native Wake Lock
 * path is handled by WakeLockManager directly.
 */

const webm =
  "data:video/webm;base64,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";

const mp4 =
  "data:video/mp4;base64,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";

class NoSleep {
  constructor() {
    this.enabled = false;
    this.noSleepVideo = document.createElement("video");
    this.noSleepVideo.setAttribute("title", "No Sleep");
    this.noSleepVideo.setAttribute("playsinline", "");

    this._addSourceToVideo(this.noSleepVideo, "webm", webm);
    this._addSourceToVideo(this.noSleepVideo, "mp4", mp4);

    this.noSleepVideo.addEventListener("loadedmetadata", () => {
      if (this.noSleepVideo.duration <= 1) {
        this.noSleepVideo.setAttribute("loop", "");
      } else {
        this.noSleepVideo.addEventListener("timeupdate", () => {
          if (this.noSleepVideo.currentTime > 0.5) {
            this.noSleepVideo.currentTime = Math.random();
          }
        });
      }
    });
  }

  _addSourceToVideo(element, type, dataURI) {
    const source = document.createElement("source");
    source.src = dataURI;
    source.type = `video/${type}`;
    element.appendChild(source);
  }

  get isEnabled() {
    return this.enabled;
  }

  enable() {
    const playPromise = this.noSleepVideo.play();
    return playPromise
      .then((res) => {
        this.enabled = true;
        return res;
      })
      .catch((err) => {
        this.enabled = false;
        throw err;
      });
  }

  disable() {
    this.noSleepVideo.pause();
    this.enabled = false;
  }
}

// --- js/utils/WakeLockManager.js ---
/**
 * WakeLockManager - Prevents the screen from sleeping.
 *
 * Multi-layered strategy:
 *   1. Native Screen Wake Lock API (modern browsers)
 *   2. Video element in DOM (keeps media subsystem active)
 *   3. Silent audio via Web Audio API (keeps audio subsystem active)
 *
 * All three strategies are initiated synchronously from enable() to
 * preserve the user gesture context (required by Safari/iOS).
 */


const hasNativeWakeLock = () =>
  typeof navigator !== 'undefined' && 'wakeLock' in navigator;

class WakeLockManager {
  constructor() {
    this._nativeLock = null;
    this._noSleep = null;
    this._audioCtx = null;
    this._audioSrc = null;
    this._visibilityHandler = null;
    this._enabled = false;
  }

  /**
   * Request wake lock using all available strategies.
   * Must be called from a user gesture handler.
   *
   * Fully synchronous — no async/await — so all three strategies
   * fire in the same call stack and the gesture token is preserved.
   */
  enable() {
    if (this._enabled) return;
    this._enabled = true;

    // Fire-and-forget: initiate native lock without awaiting
    this._requestNativeLock();

    // Activate fallbacks — native lock can be released at any time
    this._enableNoSleep();
    this._enableSilentAudio();

    if (!this._visibilityHandler) {
      this._visibilityHandler = () => {
        if (document.visibilityState === 'visible' && this._enabled) {
          this._reacquire();
        }
      };
      document.addEventListener('visibilitychange', this._visibilityHandler);
    }
  }

  /**
   * Release wake lock and stop all fallbacks.
   */
  disable() {
    this._enabled = false;

    if (this._nativeLock) {
      this._nativeLock.release();
      this._nativeLock = null;
    }

    this._disableNoSleep();
    this._disableSilentAudio();
  }

  /**
   * Full teardown — release lock and remove the visibility listener.
   */
  destroy() {
    this.disable();
    if (this._visibilityHandler) {
      document.removeEventListener('visibilitychange', this._visibilityHandler);
      this._visibilityHandler = null;
    }
  }

  /**
   * Re-acquire after tab becomes visible again.
   * Conservative: only re-request native lock and resume existing resources.
   */
  _reacquire() {
    if (!this._enabled) return;

    this._requestNativeLock();

    // Resume existing NoSleep video if it was paused
    if (this._noSleep && !this._noSleep.isEnabled) {
      try {
        this._noSleep.enable().catch(() => {});
      } catch (e) {
        // NoSleep resume failed
      }
    }

    // Resume existing audio context if suspended
    if (this._audioCtx && this._audioCtx.state === 'suspended') {
      this._audioCtx.resume().catch(() => {});
    }
  }

  /**
   * Fire-and-forget native wake lock request.
   * Guards against double requests.
   */
  _requestNativeLock() {
    if (this._nativeLock) return;
    if (!hasNativeWakeLock()) return;

    navigator.wakeLock.request('screen').then((lock) => {
      this._nativeLock = lock;
      lock.addEventListener('release', () => {
        this._nativeLock = null;
        // Auto-re-acquire if still enabled
        if (this._enabled && document.visibilityState === 'visible') {
          this._requestNativeLock();
        }
      });
    }).catch(() => {
      this._nativeLock = null;
    });
  }

  _enableNoSleep() {
    if (!this._noSleep) {
      this._noSleep = new NoSleep();

      // Safari ignores detached video elements for power management.
      // Append to DOM (hidden) so the browser treats it as active media.
      const vid = this._noSleep.noSleepVideo;
      vid.style.position = 'fixed';
      vid.style.top = '0';
      vid.style.left = '0';
      vid.style.width = '1px';
      vid.style.height = '1px';
      vid.style.opacity = '0.01';
      vid.style.pointerEvents = 'none';
      vid.style.zIndex = '-1';
      document.body.appendChild(vid);
    }
    try {
      this._noSleep.enable().catch(() => {});
    } catch (e) {
      // NoSleep enable failed
    }
  }

  _disableNoSleep() {
    if (this._noSleep) {
      this._noSleep.disable();
      const vid = this._noSleep.noSleepVideo;
      if (vid.parentNode) vid.parentNode.removeChild(vid);
      this._noSleep = null;
    }
  }

  /**
   * Play a near-silent tone via Web Audio API.
   * Many browsers keep the screen awake while audio is actively playing.
   */
  _enableSilentAudio() {
    if (this._audioSrc) return; // already running
    try {
      if (!this._audioCtx) {
        this._audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (this._audioCtx.state === 'suspended') {
        this._audioCtx.resume();
      }

      const oscillator = this._audioCtx.createOscillator();
      const gain = this._audioCtx.createGain();

      // Inaudible but technically "playing audio"
      gain.gain.value = 0.001;
      oscillator.frequency.value = 1; // 1 Hz — below human hearing
      oscillator.connect(gain);
      gain.connect(this._audioCtx.destination);
      oscillator.start();

      this._audioSrc = { oscillator, gain };
    } catch (e) {
      // Web Audio not available
    }
  }

  _disableSilentAudio() {
    if (this._audioSrc) {
      try {
        this._audioSrc.oscillator.stop();
        this._audioSrc.oscillator.disconnect();
        this._audioSrc.gain.disconnect();
      } catch (e) {
        // Already stopped
      }
      this._audioSrc = null;
    }
    if (this._audioCtx) {
      this._audioCtx.close();
      this._audioCtx = null;
    }
  }
}

// --- js/app.js ---
/**
 * TempoMate - Main Application
 *
 * Initializes all components, wires up event handling, and manages
 * the main game loop.
 */


class App {
  constructor() {
    // Core state
    this.gameState = new GameState();
    this.timerEngine = new TimerEngine();
    this.periodManager = new PeriodManager(this.gameState);
    this.moveCounter = new MoveCounter();
    this.soundManager = new SoundManager();
    this.themeManager = new ThemeManager();
    this.rotationManager = new RotationManager();
    this.inputHandler = new InputHandler();

    // UI components (initialized in init())
    this.clockDisplay = null;
    this.statusBar = null;
    this.settingsPanel = null;
    this.correctionMode = null;

    // State flags
    this._showingMoves = false;
    this._wakeLockManager = new WakeLockManager();

    this._resetPending = false;
    this._resetConfirmTimer = null;

    // Bind methods
    this._onTick = this._onTick.bind(this);
  }

  /**
   * Initialize the application.
   */
  init() {
    // Initialize theme
    this.themeManager.init();

    // Initialize rotation
    this.rotationManager.init(document.getElementById('app'));

    // Create UI components
    this.clockDisplay = new ClockDisplay(document.getElementById('clock-container'));
    this.statusBar = new StatusBar(document.getElementById('status-bar'));
    this.settingsPanel = new SettingsPanel(document.getElementById('settings-panel'));
    this.correctionMode = new CorrectionMode(document.getElementById('correction-overlay'));

    // Wire up input handling
    this._setupInput();

    // Wire up settings panel
    this.settingsPanel.setCallbacks(
      (config, optionNumber) => this._selectOption(config, optionNumber),
      () => {},
    );

    // Set up timer engine
    this.timerEngine.setTickCallback(this._onTick);

    // Load saved clock font
    const savedFontId = StorageManager.loadFont();
    const fontDef = CLOCK_FONTS.find((f) => f.id === savedFontId);
    if (fontDef) {
      document.documentElement.style.setProperty('--clock-font', fontDef.family);
    }

    // Load last option or default to option 1
    const lastOption = StorageManager.loadLastOption();
    this._loadOption(lastOption);

    // Initial render
    this._updateDisplay();
  }

  /**
   * Set up all input event handlers.
   */
  _setupInput() {
    const input = this.inputHandler;
    const faces = this.clockDisplay.getClockFaces();

    // Bind clock faces for tap
    input.bindClockFaces(faces.left, faces.right);

    // Bind keyboard
    input.bindKeyboard();

    // Bind toolbar buttons
    const pauseBtn = document.getElementById('btn-pause');
    const settingsBtn = document.getElementById('btn-settings');
    const resetBtn = document.getElementById('btn-reset');
    const soundBtn = document.getElementById('btn-sound');
    const themeBtn = document.getElementById('btn-theme');

    if (pauseBtn) input.bindButton(pauseBtn, 'togglePause', 'enterCorrection');
    if (settingsBtn) settingsBtn.addEventListener('click', () => this._openSettings());
    if (resetBtn) resetBtn.addEventListener('click', () => this._confirmReset());
    if (soundBtn) soundBtn.addEventListener('click', () => this._toggleSound());
    if (themeBtn) themeBtn.addEventListener('click', () => this._cycleTheme());

    const rotateBtn = document.getElementById('btn-rotate');
    if (rotateBtn) rotateBtn.addEventListener('click', () => this._toggleRotation());

    // Event handlers
    input.on('clockTap', (side) => this._handleClockTap(side));
    input.on('switchTurn', () => this._handleSwitchTurn());
    input.on('togglePause', () => this._handleTogglePause());
    input.on('toggleSound', () => this._toggleSound());
    input.on('toggleFreeze', () => this._toggleFreeze());
    input.on('showMoves', (show) => this._showMoves(show));
    input.on('reset', () => this._confirmReset());
    input.on('escape', () => this._handleEscape());
    input.on('navLeft', () => this._handleNav('left'));
    input.on('navRight', () => this._handleNav('right'));
    input.on('navUp', () => this._handleNav('up'));
    input.on('navDown', () => this._handleNav('down'));
    input.on('quickPreset', (num) => this._quickPreset(num));
    input.on('enterCorrection', () => this._enterCorrection());
  }

  /**
   * Handle clock face tap.
   * @param {string} side - Which side was tapped
   */
  _handleClockTap(side) {
    const gs = this.gameState;

    // Wake lock must be requested before AudioContext init — Safari's
    // transient user-activation is consumed by the first privileged API call.
    this._ensureWakeLock();
    this.soundManager.init();

    if (gs.status === GameStatus.IDLE) {
      // First tap: start the game. Tapping a side means "I'm done"
      // so the opponent's clock starts
      gs.startGame(side);
      this.periodManager.init();

      // Start turn for the now-active player
      this.periodManager.onTurnStart(gs.activePlayer);
      this.soundManager.resetBeepState();
      this.timerEngine.start();
      this._updateDisplay();
      return;
    }

    if (gs.status === GameStatus.RUNNING) {
      // Can only tap the active side to end turn
      if (side === gs.activePlayer) {
        this._switchTurn();
      }
      return;
    }

    if (gs.status === GameStatus.FROZEN) {
      // Clock is frozen, no interaction
      return;
    }
  }

  /**
   * Handle spacebar/enter to switch turns.
   */
  _handleSwitchTurn() {
    const gs = this.gameState;

    this._ensureWakeLock();
    this.soundManager.init();

    if (gs.status === GameStatus.IDLE) {
      // Start with left player's clock (right player goes first)
      gs.startGame(Player.LEFT);
      this.periodManager.init();
      this.periodManager.onTurnStart(gs.activePlayer);
      this.soundManager.resetBeepState();
      this.timerEngine.start();
      this._updateDisplay();
      return;
    }

    if (gs.status === GameStatus.RUNNING) {
      this._switchTurn();
    }
  }

  /**
   * Switch the active turn.
   */
  _switchTurn() {
    const gs = this.gameState;
    const previousActive = gs.activePlayer;

    // End turn for current player
    this.periodManager.onTurnEnd(previousActive);
    this.moveCounter.recordMove(previousActive);

    // Switch turns in game state (this increments the move counter on player state too)
    gs.switchTurn();

    // Start turn for new active player
    this.periodManager.onTurnStart(gs.activePlayer);
    this.soundManager.resetBeepState();

    this._updateDisplay();
  }

  /**
   * Handle pause toggle.
   */
  _handleTogglePause() {
    const gs = this.gameState;

    if (gs.status === GameStatus.RUNNING) {
      gs.pause();
      this.timerEngine.stop();
      this._updateDisplay();
    } else if (gs.status === GameStatus.PAUSED) {
      gs.resume();
      this.timerEngine.start();
      this._updateDisplay();
    }
  }

  /**
   * Timer tick callback.
   * @param {number} deltaMs
   */
  _onTick(deltaMs) {
    const gs = this.gameState;
    if (gs.status !== GameStatus.RUNNING || !gs.activePlayer) return;

    const result = this.periodManager.onTick(deltaMs, gs.activePlayer);
    const activeState = gs.getActivePlayerState();

    // Check sound
    if (gs.soundEnabled && activeState) {
      const method = this.periodManager.getMethod(gs.activePlayer);
      if (method && method.getType() !== TimingMethodType.UPCOUNT) {
        this.soundManager.checkAndBeep(activeState.timeMs);
      }

      // Byo-yomi moment expired beep
      if (result.momentExpired) {
        this.soundManager.playMomentBeep();
      }
    }

    if (result.expired) {
      // Set flag on the expired player regardless of freeze mode
      if (activeState && activeState.flagState === FlagState.NONE) {
        activeState.setFlag(FlagState.BLINKING);
      }

      if (gs.freezeEnabled && gs.isInFinalPeriod(gs.activePlayer)) {
        gs.freeze();
        this.timerEngine.stop();
      }
      // If not freeze, the clock continues (opponent can still play)
    }

    if (result.periodTransition) {
      if (gs.soundEnabled) {
        this.soundManager.playPeriodBeep();
      }
      this.soundManager.resetBeepState();
    }

    this._updateDisplay();
  }

  /**
   * Open the settings panel.
   */
  _openSettings() {
    if (this._resetPending) this._cancelResetConfirmation();
    const gs = this.gameState;
    // Only allow settings when idle or paused
    if (gs.status === GameStatus.RUNNING) {
      gs.pause();
      this.timerEngine.stop();
      this._updateDisplay();
    }
    this.settingsPanel.show();
  }

  /**
   * Select an option configuration.
   * @param {object} config
   * @param {number} optionNumber
   */
  _selectOption(config, optionNumber) {
    this.gameState.selectedOption = optionNumber;
    this.gameState.initGame(config);
    this.moveCounter.reset();
    StorageManager.saveLastOption(optionNumber);
    this._updateDisplay();
  }

  /**
   * Load an option by number.
   * @param {number} optionNumber
   */
  _loadOption(optionNumber) {
    if (optionNumber >= 1 && optionNumber <= Limits.TOTAL_PRESETS) {
      const preset = getPreset(optionNumber);
      if (preset) {
        this._selectOption(preset, optionNumber);
        return;
      }
    }

    if (optionNumber >= Limits.MANUAL_OPTION_START && optionNumber <= Limits.MANUAL_OPTION_END) {
      const slot = optionNumber - Limits.MANUAL_OPTION_START;
      const custom = StorageManager.loadCustomOption(slot);
      if (custom) {
        this._selectOption(custom, optionNumber);
        return;
      }
    }

    // Fallback to option 1
    const preset = getPreset(1);
    if (preset) {
      this._selectOption(preset, 1);
    }
  }

  /**
   * Quick preset selection (number keys).
   * @param {number} num
   */
  _quickPreset(num) {
    if (this.gameState.status !== GameStatus.IDLE) return;
    if (this.settingsPanel.isVisible()) return;

    const preset = getPreset(num);
    if (preset) {
      this._selectOption(preset, num);
    }
  }

  /**
   * Toggle sound.
   */
  _toggleSound() {
    this.gameState.toggleSound();
    this.soundManager.setEnabled(this.gameState.soundEnabled);
    this._updateDisplay();
  }

  /**
   * Toggle freeze mode.
   */
  _toggleFreeze() {
    this.gameState.toggleFreeze();
    this._updateDisplay();
  }

  /**
   * Confirm and execute reset (double-tap when game is not idle).
   */
  _confirmReset() {
    const gs = this.gameState;
    if (gs.status === GameStatus.IDLE) return;

    if (this._resetPending) {
      // Second tap — execute reset
      this._cancelResetConfirmation();
      this.timerEngine.stop();
      gs.reset();
      this.moveCounter.reset();
      this._updateDisplay();
      return;
    }

    // First tap — enter confirmation state
    this._resetPending = true;
    const resetBtn = document.getElementById('btn-reset');
    if (resetBtn) resetBtn.classList.add('confirm-active');
    this.statusBar.showMessage('Tap again to reset');

    this._resetConfirmTimer = setTimeout(() => {
      this._cancelResetConfirmation();
      this._updateDisplay();
    }, 3000);
  }

  /**
   * Cancel the pending reset confirmation.
   */
  _cancelResetConfirmation() {
    this._resetPending = false;
    if (this._resetConfirmTimer) {
      clearTimeout(this._resetConfirmTimer);
      this._resetConfirmTimer = null;
    }
    const resetBtn = document.getElementById('btn-reset');
    if (resetBtn) resetBtn.classList.remove('confirm-active');
    this.statusBar.clearMessage();
  }

  /**
   * Handle escape key.
   */
  _handleEscape() {
    if (this._resetPending) {
      this._cancelResetConfirmation();
      this._updateDisplay();
      return;
    }

    if (this.correctionMode.isActive()) {
      this.correctionMode.cancel();
      this.gameState.exitCorrectionMode();
      this._updateDisplay();
      return;
    }

    if (this.settingsPanel.isVisible()) {
      this.settingsPanel.hide();
      return;
    }

    // Escape can also pause
    if (this.gameState.status === GameStatus.RUNNING) {
      this._handleTogglePause();
    }
  }

  /**
   * Handle navigation keys (for settings/correction mode).
   * @param {string} direction
   */
  _handleNav(direction) {
    if (this.correctionMode.isActive()) {
      switch (direction) {
        case 'left': this.correctionMode.prevField(); break;
        case 'right': this.correctionMode.nextField(); break;
        case 'up': this.correctionMode.increment(); break;
        case 'down': this.correctionMode.decrement(); break;
      }
    }
  }

  /**
   * Enter correction mode.
   */
  _enterCorrection() {
    const gs = this.gameState;
    if (gs.status !== GameStatus.PAUSED && gs.status !== GameStatus.FROZEN) return;

    gs.enterCorrectionMode();

    this.correctionMode.enter(
      {
        leftTimeMs: gs.left.timeMs,
        rightTimeMs: gs.right.timeMs,
        leftMoves: gs.left.moves,
        rightMoves: gs.right.moves,
        leftPeriod: gs.left.currentPeriod,
        rightPeriod: gs.right.currentPeriod,
        totalPeriods: gs.optionConfig ? gs.optionConfig.periods.length : 1,
      },
      (corrected) => {
        // Apply corrections
        gs.left.timeMs = corrected.leftTimeMs;
        gs.right.timeMs = corrected.rightTimeMs;
        gs.left.moves = corrected.leftMoves;
        gs.right.moves = corrected.rightMoves;
        gs.left.currentPeriod = corrected.leftPeriod;
        gs.right.currentPeriod = corrected.rightPeriod;

        // Update move counter
        this.moveCounter.setMoves('left', corrected.leftMoves);
        this.moveCounter.setMoves('right', corrected.rightMoves);

        // Clamp period indices to valid range
        if (gs.optionConfig) {
          const maxPeriod = gs.optionConfig.periods.length - 1;
          gs.left.currentPeriod = Math.max(0, Math.min(corrected.leftPeriod, maxPeriod));
          gs.right.currentPeriod = Math.max(0, Math.min(corrected.rightPeriod, maxPeriod));

          // Sync period methods
          const leftPeriodConfig = gs.optionConfig.periods[gs.left.currentPeriod];
          const rightPeriodConfig = gs.optionConfig.periods[gs.right.currentPeriod];
          if (leftPeriodConfig) {
            this.periodManager.activeMethods.set('left', PeriodManager.createMethod(leftPeriodConfig));
          }
          if (rightPeriodConfig) {
            this.periodManager.activeMethods.set('right', PeriodManager.createMethod(rightPeriodConfig));
          }
        }

        gs.exitCorrectionMode();
        this._updateDisplay();
      },
      () => {
        gs.exitCorrectionMode();
        this._updateDisplay();
      },
    );
  }

  /**
   * Show/hide move count.
   * @param {boolean} show
   */
  _showMoves(show) {
    this._showingMoves = show;
    this._updateDisplay();
  }

  /**
   * Cycle through themes.
   */
  _cycleTheme() {
    const newTheme = this.themeManager.cycle();
    const btn = document.getElementById('btn-theme');
    if (btn) {
      const icons = { auto: '\u25D0', light: '\u2600', dark: '\u263E' };
      btn.textContent = icons[newTheme] || '\u25D0';
      btn.title = `Theme: ${newTheme}`;
    }
  }

  /**
   * Toggle 90° rotation.
   */
  _toggleRotation() {
    const rotated = this.rotationManager.toggle();
    const btn = document.getElementById('btn-rotate');
    if (btn) {
      btn.title = rotated ? 'Undo rotation' : 'Rotate 90\u00B0';
    }
    this.clockDisplay.clearFontSizeCache();
    requestAnimationFrame(() => {
      this.clockDisplay._syncFontSizes();
    });
  }

  /**
   * Update all display elements.
   */
  _updateDisplay() {
    const gs = this.gameState;

    // Update clock display
    this.clockDisplay.update({
      leftTimeMs: gs.left.timeMs,
      rightTimeMs: gs.right.timeMs,
      activePlayer: gs.activePlayer,
      gameStatus: gs.status,
      leftColor: gs.left.color,
      rightColor: gs.right.color,
      leftFlagState: gs.left.flagState,
      rightFlagState: gs.right.flagState,
      leftMoves: gs.left.moves,
      rightMoves: gs.right.moves,
      showMoves: this._showingMoves,
      leftByoMoments: gs.left.byoMomentsRemaining,
      rightByoMoments: gs.right.byoMomentsRemaining,
      leftMethod: this.periodManager.getMethodType('left'),
      rightMethod: this.periodManager.getMethodType('right'),
    });

    // Update status bar
    const activePlayer = gs.getActivePlayerState();
    const whitePlayer = gs.left.color === 'white' ? 'left' : 'right';
    this.statusBar.update({
      leftMethod: this.periodManager.getMethodType('left'),
      rightMethod: this.periodManager.getMethodType('right'),
      leftPeriod: gs.left.currentPeriod,
      rightPeriod: gs.right.currentPeriod,
      totalPeriods: gs.optionConfig ? gs.optionConfig.periods.length : 1,
      freezeEnabled: gs.freezeEnabled,
      soundEnabled: gs.soundEnabled,
      optionNumber: gs.selectedOption,
      moveNumber: this.moveCounter.getChessMoveNumber(whitePlayer),
      gameStatus: gs.status,
      delayRemainingMs: activePlayer ? activePlayer.delayRemainingMs : 0,
    });

    // Update button states
    const pauseBtn = document.getElementById('btn-pause');
    if (pauseBtn) {
      const isPaused = gs.status === GameStatus.PAUSED;
      const isRunning = gs.status === GameStatus.RUNNING;
      pauseBtn.textContent = isPaused ? '\u25B6' : '\u23F8'; // Play or Pause icon
      pauseBtn.title = isPaused ? 'Resume (P)' : 'Pause (P)';
      pauseBtn.disabled = !isRunning && !isPaused;
    }

    const soundBtn = document.getElementById('btn-sound');
    if (soundBtn) {
      soundBtn.textContent = gs.soundEnabled ? '\u266B' : '\u266A';
      soundBtn.title = gs.soundEnabled ? 'Sound ON (S)' : 'Sound OFF (S)';
      soundBtn.classList.toggle('active', gs.soundEnabled);
    }
  }

  /**
   * Enable wake lock on first user gesture.
   * WakeLockManager.enable() is synchronous and fires all three strategies
   * (native + video + audio) in the same call stack, preserving the gesture.
   */
  _ensureWakeLock() {
    this._wakeLockManager.enable();
  }

  /**
   * Clean up resources.
   */
  destroy() {
    this.timerEngine.destroy();
    this.soundManager.destroy();
    this.themeManager.destroy();
    this.rotationManager = null;
    this.inputHandler.destroy();
    this._wakeLockManager.destroy();
  }
}



// Auto-initialize
if (!window.__tempoMateApp) {
  document.addEventListener('DOMContentLoaded', () => {
    if (!window.__tempoMateApp) {
      const app = new App();
      app.init();
      window.__tempoMateApp = app;
    }
  });
}
  </script>
</body>
</html>
